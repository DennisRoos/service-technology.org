{Output Port des zweiten Wrappers}


{01: konkret}
{02: OR entfernt, weil im wrapper_01 auch OR im OP weggelassen.}
{    INT_CLK = LCLKM or REQ_INT}
{03: AND und beide D-FFs zusammenfassen; rst an D-FFs schaltet immer vor}
{     INT_CLK}
{04: Einzelner Pegelplatz kodiert nicht mehr Pegel für alle Signale, sondern}
{    jeweils zwei Plätze kodieren Pegel für ein Signal}
{05: stark abstrahiert}


PLACE
    op.p.INT_CLK,
    op.p.n_INT_CLK,
    op.p.pegel_INT_CLK_0,
    op.p.pegel_INT_CLK_1,
    op.p.pegel_DATAV_OUT_0,
    op.p.pegel_DATAV_OUT_1,

    {Output Controller im OP}
    op.oc.p.0,  {Zustände des Output Controllers}
    op.oc.p.1,
    op.oc.p.2,
    op.oc.p.3,
    op.oc.p.DOV+,        {Platz für steigende DOV-Flanke}
    op.oc.p.n_DOV+,
    op.oc.p.DONV+,       {Platz für steigende DONV-Flanke}
    op.oc.p.n_DONV+,
    op.oc.p.DOVDONV-,    {Platz für fallende DOV- bzw. DONV-Flanken}
    op.oc.p.n_DOVDONV-,  {ob DOV oder DONV weiß der OC anhand seines Zustands}
    op.oc.p.STRETCH,
    op.oc.p.n_STRETCH,
    op.oc.p.ACK_INT,
    op.oc.p.n_ACK_INT;


MARKING
    op.p.n_INT_CLK: 1,
    op.p.pegel_INT_CLK_0: 1,
    op.p.pegel_DATAV_OUT_0: 1,

    op.oc.p.0: 1,
    op.oc.p.n_DOV+: 1,
    op.oc.p.n_DONV+: 1,
    op.oc.p.n_DOVDONV-: 1,
    op.oc.p.n_STRETCH: 1,
    op.oc.p.n_ACK_INT: 1;



{Pegelkodierung: (INT_CLK, DATAV_OUT)}

{INT_CLK+ bei DATAV_OUT=0 erzeugt DONV+}
TRANSITION op.t.INT_CLK_1_pegel_0_0
CONSUME op.p.INT_CLK: 1, op.p.pegel_INT_CLK_0: 1, op.p.pegel_DATAV_OUT_0: 1,
        op.oc.p.n_DONV+: 1;
PRODUCE op.p.n_INT_CLK: 1, op.p.pegel_INT_CLK_1: 1, op.p.pegel_DATAV_OUT_0: 1,
        op.oc.p.DONV+: 1;

{INT_CLK+ bei DATAV_OUT=1 erzeugt DOV+}
TRANSITION op.t.INT_CLK_1_pegel_0_1
CONSUME op.p.INT_CLK: 1, op.p.pegel_INT_CLK_0: 1, op.p.pegel_DATAV_OUT_1: 1,
        op.oc.p.n_DOV+: 1;
PRODUCE op.p.n_INT_CLK: 1, op.p.pegel_INT_CLK_1: 1, op.p.pegel_DATAV_OUT_1: 1,
        op.oc.p.DOV+: 1;

{INT_CLK- erzeugt DOV- bzw. DONV-}
TRANSITION op.t.INT_CLK_0_pegel_1_x
CONSUME op.p.INT_CLK: 1, op.p.pegel_INT_CLK_1: 1, op.oc.p.n_DOVDONV-: 1;
PRODUCE op.p.n_INT_CLK: 1, op.p.pegel_INT_CLK_0: 1, op.oc.p.DOVDONV-: 1;


{Output Controller im OP}

TRANSITION op.oc.t.01
CONSUME op.oc.p.0: 1, op.oc.p.DOV+: 1, op.oc.p.n_STRETCH: 1,
        op.oc.p.n_ACK_INT: 1;
PRODUCE op.oc.p.1: 1, op.oc.p.n_DOV+: 1, op.oc.p.STRETCH: 1,
        op.oc.p.ACK_INT: 1;

TRANSITION op.oc.t.03
CONSUME op.oc.p.0: 1, op.oc.p.DONV+: 1, op.oc.p.n_ACK_INT: 1;
PRODUCE op.oc.p.3: 1, op.oc.p.n_DONV+: 1, op.oc.p.ACK_INT: 1;

TRANSITION op.oc.t.12
CONSUME op.oc.p.1: 1, op.oc.p.DOVDONV-: 1, op.oc.p.n_STRETCH: 1,
        op.oc.p.n_ACK_INT: 1;
PRODUCE op.oc.p.2: 1, op.oc.p.n_DOVDONV-: 1, op.oc.p.STRETCH: 1,
        op.oc.p.ACK_INT: 1;

TRANSITION op.oc.t.21
CONSUME op.oc.p.2: 1, op.oc.p.DOV+: 1, op.oc.p.n_STRETCH: 1,
        op.oc.p.n_ACK_INT: 1;
PRODUCE op.oc.p.1: 1, op.oc.p.n_DOV+: 1, op.oc.p.STRETCH: 1,
        op.oc.p.ACK_INT: 1;

TRANSITION op.oc.t.23
CONSUME op.oc.p.2: 1, op.oc.p.DONV+: 1, op.oc.p.n_ACK_INT: 1;
PRODUCE op.oc.p.3: 1, op.oc.p.n_DONV+: 1, op.oc.p.ACK_INT: 1;

TRANSITION op.oc.t.30
CONSUME op.oc.p.3: 1, op.oc.p.DOVDONV-: 1, op.oc.p.n_ACK_INT: 1;
PRODUCE op.oc.p.0: 1, op.oc.p.n_DOVDONV-: 1, op.oc.p.ACK_INT: 1;



{Anbindung an Aussenwelt}

{DATAV_OUT-Pegel wechseln}
TRANSITION op.t.DATAV_OUT+
CONSUME op.p.pegel_DATAV_OUT_0: 1;
PRODUCE op.p.pegel_DATAV_OUT_1: 1;

{DATAV_OUT-Pegel wechseln}
TRANSITION op.t.DATAV_OUT-
CONSUME op.p.pegel_DATAV_OUT_1: 1;
PRODUCE op.p.pegel_DATAV_OUT_0: 1;

{INT_CLK produzieren}
TRANSITION op.t.INT_CLK
CONSUME op.p.n_INT_CLK: 1;
PRODUCE op.p.INT_CLK: 1;

{ACK_INT abräumen}
TRANSITION op.t.ACK_INT
CONSUME op.oc.p.ACK_INT: 1;
PRODUCE op.oc.p.n_ACK_INT: 1;

{STRETCH abräumen}
TRANSITION op.t.STRETCH
CONSUME op.oc.p.STRETCH: 1;
PRODUCE op.oc.p.n_STRETCH: 1;



{ vim: set ft=lola: }
