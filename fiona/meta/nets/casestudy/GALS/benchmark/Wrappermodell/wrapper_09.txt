{Zweiter Wrapper}

{01: konkret; alle Gatter einzeln}
{02: alle Komponenten zusammengefasst bzw. abstrahiert.}
{    Hazards nur noch im Input Port erkennbar (an zusammengefassten Gattern)}
{    eingebaute Komponenten:}
{       clock_control_03, input_port_02, output_port_04,}
{       pausable_clock_generator_02, timeout_generator_02, lsm_02, and-or_02}
{02b: wie 02 mit folgenden Einschränkungen:}
{       * Der Input Port darf höchstens einmal von Zustand 0 nach 1 übergehen.}
{       * Der Input Port darf höchstens einmal von Zustand 2 nach 1 übergehen.}
{03: wie 02b mit:}
{       * timeout_generator_03 eingebaut (abstrakt)}
{       * pausable_clock_generator_03 eingebaut (abstrakt)}
{       * output_port_05 eingebaut (abstrakt)}
{04: input_port_03 eingebaut}
{05: * clock_control_04 eingebaut}
{    * im TOG Transitionen, die STOPH nach STOP und REQ_A nach REQ_A1}
{      durchschalten, eingespart. Stattdessen wird direkt STOP und REQ_A1}
{      produziert}
{06: korrigierten abstrakten Input Port eingebaut (input_port_04)}


PLACE
    {Timeout Generator}

    {tog.p.STOPH und tog.p.REQ_A eingespart, da abstrakter TOG nur}
    {durchschaltet auf ip.ic.p.STOP und ip.ic.p.REQ_A1. Wer voher tog.p.STOPH}
    {und tog.p.REQ_A produzierte, produziert jetzt direkt ip.ic.p.STOP und}
    {ip.ic.p.REQ_A1.}
    tog.p.LCLK,
    tog.p.n_LCLK,
    tog.p.RST,
    tog.p.n_RST,
    {tog.p.STOP => ip.ic.p.STOP}  {Output-Flanken}
    {tog.p.REQ_A1 => ip.ic.p.REQ_A1}
    {tog.p.ST => ip.ic.p.ST, andor.p.ST, cc.p.ST}
    tog.p.pegel_RST_0,
    tog.p.pegel_RST_1,
    tog.p.pegel_ST_0,
    tog.p.pegel_ST_1,

    {Input Port}

    ip.p.LCLKM,  {Input/Outputflanken}
    ip.p.n_LCLKM,
    {ip.p.INT_CLK entfällt}
    {ip.p.ACK_INT => ip.ic.p.ACKC}
    {ip.p.DATAV_IN => lsm.p.DATAV_IN}
    ip.p.ACK_A+,  {Hilfsplätze}
    ip.p.n_ACK_A+,
    ip.p.pegel_ACK_EN_0,
    ip.p.ACK_EN+,
    ip.p.n_ACK_EN+,
    ip.p.ACKC+,
    ip.p.n_ACKC+,
    ip.p.ACKC-_abzuraeumen, {wenn markiert, ACKC(-) abzuräumen, bevor IP weiterschalten kann}
    ip.p.n_ACKC-_abzuraeumen, {Komplementärplatz}

    {Input Controller im IP}
    ip.ic.p.0,  {Zustände des Input Controllers}
    ip.ic.p.1,
    ip.ic.p.2,
    ip.ic.p.3,
    ip.ic.p.4,
    ip.ic.p.5,
    ip.ic.p.6,
    ip.ic.p.7,
    ip.ic.p.8,
    ip.ic.p.erlaube_transition_01, {damit IP nur eine Runde läuft}
    ip.ic.p.erlaube_transition_21,
    ip.ic.p.REQ_A1,    {Eingabesignale als Flanken}
    ip.ic.p.n_REQ_A1,
    ip.ic.p.ST,
    ip.ic.p.n_ST,
    ip.ic.p.STOP,
    ip.ic.p.n_STOP,
    ip.ic.p.ACKC,
    ip.ic.p.n_ACKC,
    ip.ic.p.ACKI1,
    ip.ic.p.n_ACKI1,
    {ip.ic.p.ACK_A => ip.ic.p.REQ_A1}  {Ausgabesignale als Flanken}
    {ip.ic.p.RST => tog.p.RST, cc.p.RST}
    {ip.ic.p.REQ_INT => cc.p.REQ_INT , andor.p.REQ_INT}
    {ip.ic.p.REQI1 => pcg.p.REQI1}

    {Clock Control}

    cc.p.ACK_INT, {Input-Flanken}
    cc.p.n_ACK_INT,
    cc.p.RST,
    cc.p.n_RST,
    cc.p.REQ_INT,
    cc.p.n_REQ_INT,
    {cc.p.STOPH => ip.ic.p.STOP}  {Output-Flanken}
    {cc.p.STOPI => pcg.p.STOPI}
    cc.p.pegel_STOPH_0,
    cc.p.pegel_STOPH_1,
    cc.p.pegel_STOPI_0,
    cc.p.pegel_STOPI_1,
    {STOPH darf nicht produziert werden, wenn IC über 5 nach 0 geht.}
    cc.p.erlaube_stop, {bei Einbau in Wrapper IC entsprechend modifizieren}


    {Pausable Clock Generator}

    pcg.p.STOPI,
    pcg.p.n_STOPI,
    pcg.p.REQI1,
    pcg.p.n_REQI1,
    pcg.p.STRETCH,
    pcg.p.n_STRETCH,
    {pcg.p.ACKI1 => ip.ic.p.ACKI1}
    {pcg.p.LCLK => andor.p.LCLK, tog.p.LCLK}
    pcg.p.pegel_STOPI_0,
    pcg.p.pegel_STOPI_1,
    pcg.p.pegel_REQI1_0,
    pcg.p.pegel_REQI1_1,
    pcg.p.pegel_STRETCH_0,
    pcg.p.pegel_STRETCH_1,
    pcg.p.pegel_LCLK_0,
    pcg.p.pegel_LCLK_1,

    {Output Port}

    op.p.INT_CLK,
    op.p.n_INT_CLK,
    op.p.pegel_INT_CLK_0,
    op.p.pegel_INT_CLK_1,
    {op.p.pegel_DATAV_OUT_0 => lsm.p.pegel_DATAV_OUT_0}
    {op.p.pegel_DATAV_OUT_1 => lsm.p.pegel_DATAV_OUT_1}

    {Output Controller im OP}
    op.oc.p.0,  {Zustände des Output Controllers}
    op.oc.p.1,
    op.oc.p.2,
    op.oc.p.3,
    op.oc.p.DOV+,        {Platz für steigende DOV-Flanke}
    op.oc.p.n_DOV+,
    op.oc.p.DONV+,       {Platz für steigende DONV-Flanke}
    op.oc.p.n_DONV+,
    op.oc.p.DOVDONV-,    {Platz für fallende DOV- bzw. DONV-Flanken}
    op.oc.p.n_DOVDONV-,  {ob DOV oder DONV weiß der OC anhand seines Zustands}
    {op.oc.p.STRETCH => pcg.p.STRETCH}
    {op.oc.p.ACK_INT => ip.ic.p.ACKC, cc.p.ACK_INT}

    {AND im Wrapper}
    and.p.LCLK,
    and.p.n_LCLK,
    {andor.p.or_out => lsm.p.INT_CLK, op.p.INT_CLK}
    {andor.p.and_out => ip.p.LCLKM}


    {Locally Synchronous Module}

    lsm.p.pegel_DATAV_OUT_0,
    lsm.p.pegel_DATAV_OUT_1;



MARKING
    tog.p.n_LCLK: 1,
    tog.p.n_RST: 1,
    
    tog.p.pegel_RST_0: 1,
    tog.p.pegel_ST_0: 1,

    ip.p.n_LCLKM: 1,


    ip.p.pegel_ACK_EN_0: 1,
    ip.p.n_ACK_A+: 1,
    ip.p.n_ACK_EN+: 1,
    ip.p.n_ACKC+: 1,
    ip.p.n_ACKC-_abzuraeumen: 1,

    ip.ic.p.0: 1,
    ip.ic.p.erlaube_transition_01: 1,
    ip.ic.p.erlaube_transition_21: 1,
    ip.ic.p.REQ_A1: 1,  {Es gibt eine Anfrage vom Vorgängerwrapper}
    ip.ic.p.n_ST: 1,
    ip.ic.p.n_STOP: 1,
    ip.ic.p.n_ACKC: 1,
    ip.ic.p.n_ACKI1: 1,


    cc.p.n_ACK_INT: 1,
    cc.p.n_RST: 1,
    cc.p.n_REQ_INT: 1,



    cc.p.pegel_STOPH_0: 1,
    cc.p.pegel_STOPI_1: 1, {STOPI mit 1 initialisiert}
    cc.p.erlaube_stop: 1,

    pcg.p.n_STOPI: 1,
    pcg.p.n_REQI1: 1,
    pcg.p.n_STRETCH: 1,
    pcg.p.pegel_STOPI_1: 1, {STOPI initial 1}
    pcg.p.pegel_REQI1_0: 1,
    pcg.p.pegel_STRETCH_0: 1,
    pcg.p.pegel_LCLK_0: 1,

    op.p.n_INT_CLK: 1,
    op.p.pegel_INT_CLK_0: 1,

    op.oc.p.0: 1,
    op.oc.p.n_DOV+: 1,
    op.oc.p.n_DONV+: 1,
    op.oc.p.n_DOVDONV-: 1,

    and.p.n_LCLK: 1,
    




    lsm.p.pegel_DATAV_OUT_0: 1;


{LCLK+ ohne Effekt an Ausgängen}

{LCLK- ohne Effekt an Ausgängen, falls RST=1}
TRANSITION tog.t.LCLK_0_pegel_11x
CONSUME tog.p.LCLK: 1, pcg.p.pegel_LCLK_0: 1, tog.p.pegel_RST_1: 1;
PRODUCE tog.p.n_LCLK: 1, pcg.p.pegel_LCLK_0: 1, tog.p.pegel_RST_1: 1;

{LCLK- belässt ST=1, falls ST=1 und RST=0}
TRANSITION tog.t.LCLK_0_pegel_101
CONSUME tog.p.LCLK: 1, pcg.p.pegel_LCLK_0: 1, tog.p.pegel_RST_0: 1,
        tog.p.pegel_ST_1: 1;
PRODUCE tog.p.n_LCLK: 1, pcg.p.pegel_LCLK_0: 1, tog.p.pegel_RST_0: 1,
        tog.p.pegel_ST_1: 1;

{LCLK- führt zu ST+, falls RST=ST=0}
TRANSITION tog.t.LCLK_0_pegel_100
CONSUME tog.p.LCLK: 1, pcg.p.pegel_LCLK_0: 1, tog.p.pegel_RST_0: 1,
        tog.p.pegel_ST_0: 1, ip.ic.p.n_ST: 1;
PRODUCE tog.p.n_LCLK: 1, pcg.p.pegel_LCLK_0: 1, tog.p.pegel_RST_0: 1,
        tog.p.pegel_ST_1: 1, ip.ic.p.ST: 1;



{RST- ohne Effekt an Ausgängen}
TRANSITION tog.t.RST_0_pegel_x1x
CONSUME tog.p.RST: 1, tog.p.pegel_RST_1: 1;
PRODUCE tog.p.n_RST: 1, tog.p.pegel_RST_0: 1;

{RST+ führt zu ST-, falls ST=1}
TRANSITION tog.t.RST_1_pegel_x01
CONSUME tog.p.RST: 1, tog.p.pegel_RST_0: 1, tog.p.pegel_ST_1: 1,
        ip.ic.p.n_ST: 1; 
PRODUCE tog.p.n_RST: 1, tog.p.pegel_RST_1: 1, tog.p.pegel_ST_0: 1,
        ip.ic.p.ST: 1;

{RST+ belässt ST=0, falls ST=0}
TRANSITION tog.t.RST_1_pegel_x00
CONSUME tog.p.RST: 1, tog.p.pegel_RST_0: 1, tog.p.pegel_ST_0: 1; 
PRODUCE tog.p.n_RST: 1, tog.p.pegel_RST_1: 1, tog.p.pegel_ST_0: 1;


{Pegelkodierung: LCLKM, DATAV_IN}

TRANSITION ip.t.LCLKM_1_pegel_0_0
CONSUME ip.p.LCLKM: 1, lsm.p.pegel_DATAV_OUT_0: 1;
PRODUCE ip.p.n_LCLKM: 1, lsm.p.pegel_DATAV_OUT_0: 1;

TRANSITION ip.t.LCLKM_1_pegel_0_1
CONSUME ip.p.LCLKM: 1, lsm.p.pegel_DATAV_OUT_1: 1;
PRODUCE ip.p.n_LCLKM: 1, lsm.p.pegel_DATAV_OUT_0: 1;


{Input Controller im IP}

TRANSITION ip.ic.t.01
CONSUME ip.ic.p.0: 1, ip.ic.p.REQ_A1: 1, cc.p.n_REQ_INT: 1,
        op.p.n_INT_CLK: 1, tog.p.n_RST: 1, cc.p.n_RST: 1,
        ip.p.n_ACK_A+: 1, ip.ic.p.erlaube_transition_01: 1;
PRODUCE ip.ic.p.1: 1, ip.ic.p.REQ_A1: 1, cc.p.REQ_INT: 1, op.p.INT_CLK: 1,
        tog.p.RST: 1, cc.p.RST: 1, ip.p.ACK_A+: 1;

TRANSITION ip.ic.t.12
CONSUME ip.ic.p.1: 1, ip.ic.p.ACKC: 1, ip.p.ACKC+: 1, ip.ic.p.REQ_A1: 1,
        op.p.n_INT_CLK: 1, tog.p.n_RST: 1, cc.p.n_RST: 1;
PRODUCE ip.ic.p.2: 1, ip.ic.p.n_ACKC: 1, ip.p.n_ACKC+: 1, ip.ic.p.REQ_A1: 1,
        op.p.INT_CLK: 1, tog.p.RST: 1, cc.p.RST: 1;

TRANSITION ip.ic.t.21
CONSUME ip.ic.p.2: 1, ip.ic.p.ACKC: 1, ip.ic.p.REQ_A1: 1, cc.p.n_REQ_INT: 1,
        op.p.n_INT_CLK: 1, tog.p.n_RST: 1, cc.p.n_RST: 1,
        ip.p.n_ACK_A+: 1, ip.ic.p.erlaube_transition_21: 1;
PRODUCE ip.ic.p.1: 1, ip.ic.p.n_ACKC: 1, ip.ic.p.REQ_A1: 1, cc.p.REQ_INT: 1,
        op.p.INT_CLK: 1, tog.p.RST: 1, cc.p.RST: 1, ip.p.ACK_A+: 1;

TRANSITION ip.ic.t.23
CONSUME ip.ic.p.2: 1, ip.ic.p.ACKC: 1, ip.ic.p.ST: 1;
PRODUCE ip.ic.p.3: 1, ip.ic.p.n_ACKC: 1, ip.ic.p.n_ST: 1;

TRANSITION ip.ic.t.34
CONSUME ip.ic.p.3: 1, ip.ic.p.STOP: 1, tog.p.n_RST: 1, cc.p.n_RST: 1,
        ip.p.n_ACKC-_abzuraeumen: 1;
PRODUCE ip.ic.p.4: 1, ip.ic.p.n_STOP: 1, tog.p.RST: 1, cc.p.RST: 1,
        ip.p.n_ACKC-_abzuraeumen: 1;

TRANSITION ip.ic.t.40
CONSUME ip.ic.p.4: 1, ip.ic.p.STOP: 1, ip.ic.p.ST: 1, tog.p.n_RST: 1,
        cc.p.n_RST: 1;
PRODUCE ip.ic.p.0: 1, ip.ic.p.n_STOP: 1, ip.ic.p.n_ST: 1, tog.p.RST: 1,
        cc.p.RST: 1;

TRANSITION ip.ic.t.35
CONSUME ip.ic.p.3: 1, ip.ic.p.REQ_A1: 1, pcg.p.n_REQI1: 1, cc.p.erlaube_stop: 1,
        ip.p.n_ACKC-_abzuraeumen: 1;
PRODUCE ip.ic.p.5: 1, ip.ic.p.n_REQ_A1: 1, pcg.p.REQI1: 1,
        ip.p.n_ACKC-_abzuraeumen: 1;

TRANSITION ip.ic.t.56
CONSUME ip.ic.p.5: 1, ip.ic.p.ACKI1: 1, ip.p.n_ACK_EN+: 1, pcg.p.n_REQI1: 1,
        ip.p.pegel_ACK_EN_0: 1;
PRODUCE ip.ic.p.6: 1, ip.ic.p.n_ACKI1: 1, ip.p.ACK_EN+: 1, pcg.p.REQI1: 1;

TRANSITION ip.ic.t.67
CONSUME ip.ic.p.6: 1, ip.ic.p.ACKI1: 1, ip.ic.p.ACKC: 1;
PRODUCE ip.ic.p.7: 1, ip.ic.p.n_ACKI1: 1, ip.ic.p.n_ACKC: 1;

TRANSITION ip.ic.t.78
CONSUME ip.ic.p.7: 1, ip.ic.p.ACKC: 1, ip.ic.p.n_REQ_A1: 1, tog.p.n_RST: 1,
        cc.p.n_RST: 1;
PRODUCE ip.ic.p.8: 1, ip.ic.p.n_ACKC: 1, ip.ic.p.REQ_A1: 1, tog.p.RST: 1,
        cc.p.RST: 1;

TRANSITION ip.ic.t.80
CONSUME ip.ic.p.8: 1, ip.ic.p.REQ_A1: 1, ip.ic.p.ST: 1,
        tog.p.n_RST: 1, cc.p.n_RST: 1;
PRODUCE ip.ic.p.0: 1, ip.ic.p.REQ_A1: 1, ip.ic.p.n_ST: 1,
        tog.p.RST: 1, cc.p.RST: 1, ip.p.pegel_ACK_EN_0: 1, cc.p.erlaube_stop: 1;



TRANSITION ip.t.DATAV_IN+_durch_ACK_A
CONSUME ip.p.ACK_A+: 1, ip.p.pegel_ACK_EN_0: 1, lsm.p.pegel_DATAV_OUT_0: 1;
PRODUCE ip.p.n_ACK_A+: 1, ip.p.pegel_ACK_EN_0: 1, lsm.p.pegel_DATAV_OUT_1: 1;

TRANSITION ip.t.DATAV_IN+_durch_ACK_C
CONSUME ip.p.ACKC+: 1, ip.p.ACK_EN+: 1, lsm.p.pegel_DATAV_OUT_0: 1;
PRODUCE ip.p.n_ACKC+: 1, ip.p.n_ACK_EN+: 1, lsm.p.pegel_DATAV_OUT_1: 1;



{Wenn IC im Zustand 3, dann können beliebig viele Flankenpaare ACKC+/ACKC-}
{abgeräumt werden}
TRANSITION ip.t.ACKC+_abraeumen
CONSUME ip.ic.p.3: 1, ip.p.n_ACKC-_abzuraeumen: 1, ip.ic.p.ACKC: 1,
        ip.p.ACKC+: 1;
PRODUCE ip.ic.p.3: 1, ip.p.ACKC-_abzuraeumen: 1;

TRANSITION ip.t.ACKC-_abraeumen
CONSUME ip.p.ACKC-_abzuraeumen: 1, ip.ic.p.ACKC: 1;
PRODUCE ip.p.n_ACKC-_abzuraeumen: 1;



{Clock Control}



TRANSITION cc.t.ACK_INT-_ignorieren
CONSUME cc.p.ACK_INT: 1;
PRODUCE cc.p.n_ACK_INT: 1; 

TRANSITION cc.t.counter_erreicht_max
CONSUME cc.p.ACK_INT: 1, tog.p.pegel_ST_0: 1,
        cc.p.pegel_STOPH_0: 1, cc.p.pegel_STOPI_0: 1,
        cc.p.erlaube_stop: 1, ip.ic.p.n_STOP: 1, pcg.p.n_STOPI: 1;
PRODUCE cc.p.n_ACK_INT: 1, tog.p.pegel_ST_0: 1,
        cc.p.pegel_STOPH_1: 1, cc.p.pegel_STOPI_1: 1,
        cc.p.erlaube_stop: 1, ip.ic.p.STOP: 1, pcg.p.STOPI: 1;


TRANSITION cc.t.RST_keine_stoph_flanke
CONSUME cc.p.RST: 1, cc.p.pegel_STOPH_0: 1;
PRODUCE cc.p.n_RST: 1, cc.p.pegel_STOPH_0: 1;

TRANSITION cc.t.RST_stoph_flanke
CONSUME cc.p.RST: 1, ip.ic.p.4: 1, cc.p.pegel_STOPH_1: 1, ip.ic.p.n_STOP: 1;
PRODUCE cc.p.n_RST: 1, ip.ic.p.4: 1, cc.p.pegel_STOPH_0: 1, ip.ic.p.STOP: 1;


TRANSITION cc.t.REQ_INT_1_pegel_STOPI_0
CONSUME cc.p.REQ_INT: 1, cc.p.pegel_STOPI_0: 1;
PRODUCE cc.p.n_REQ_INT: 1, cc.p.pegel_STOPI_0: 1;

TRANSITION cc.t.REQ_INT_1_pegel_STOPI_1
CONSUME cc.p.REQ_INT: 1, cc.p.pegel_STOPI_1: 1, pcg.p.n_STOPI: 1;
PRODUCE cc.p.n_REQ_INT: 1, cc.p.pegel_STOPI_0: 1, pcg.p.STOPI: 1;




{Pausable Clock Generator}

{STOPI-Flanke aktualisiert Pegel}

TRANSITION pcg.t.STOPI-
CONSUME pcg.p.STOPI: 1, pcg.p.pegel_STOPI_1: 1;
PRODUCE pcg.p.n_STOPI: 1, pcg.p.pegel_STOPI_0: 1;

TRANSITION pcg.t.STOPI+
CONSUME pcg.p.STOPI: 1, pcg.p.pegel_STOPI_0: 1;
PRODUCE pcg.p.n_STOPI: 1, pcg.p.pegel_STOPI_1: 1;



{LCLK+ kann erzeugt werden, wenn STOPI=REQI1=STRETCH=LCLK=0}
{Dabei werden Pegelmarken von REQI1 und STRETCH konsumiert und erst bei}
{Erzeugung von LCLK- wieder produziert. Dadurch werden Flanken an REQI1 und}
{STRETCH erst wieder nach LCLK- verarbeitet (also: Mutex-Verhalten).}
TRANSITION pcg.t.LCLK+
CONSUME pcg.p.pegel_LCLK_0: 1, pcg.p.pegel_STOPI_0: 1, pcg.p.pegel_REQI1_0: 1,
        pcg.p.pegel_STRETCH_0: 1, and.p.n_LCLK: 1;
PRODUCE pcg.p.pegel_LCLK_1: 1, pcg.p.pegel_STOPI_0: 1,
        and.p.LCLK: 1;

{LCLK- kann immer erzeugt werden, wenn LCLK=1}
{Pegelmarken für REQI1 und STRETCH (beide =0), die pcg.t.LCLK+ konsumiert hat,}
{müssen wieder produziert werden. Erklärung siehe dort.}
TRANSITION pcg.t.LCLK-
CONSUME pcg.p.pegel_LCLK_1: 1, and.p.n_LCLK: 1, tog.p.n_LCLK: 1;
PRODUCE pcg.p.pegel_LCLK_0: 1, pcg.p.pegel_REQI1_0: 1, pcg.p.pegel_STRETCH_0: 1,
        and.p.LCLK: 1, tog.p.LCLK: 1;



{REQI1-Flanke}

{REQI1+ => ACKI1+ (Mutex-Verhalten wird erreicht durch Transition pcg.t.LCLK+,}
{die Marken von pcg.p.pegel_REQI1_0 entfernt)}
TRANSITION pcg.t.REQI1+
CONSUME pcg.p.REQI1: 1, pcg.p.pegel_REQI1_0: 1, ip.ic.p.n_ACKI1: 1;
PRODUCE pcg.p.n_REQI1: 1, pcg.p.pegel_REQI1_1: 1, ip.ic.p.ACKI1: 1;

{REQI1- => ACKI1-}
TRANSITION pcg.t.REQI1-
CONSUME pcg.p.REQI1: 1, pcg.p.pegel_REQI1_1: 1, ip.ic.p.n_ACKI1: 1;
PRODUCE pcg.p.n_REQI1: 1, pcg.p.pegel_REQI1_0: 1, ip.ic.p.ACKI1: 1;


{STRETCH-Flanke}

{STRETCH analog zu REQI1 (nur ohne Flankenausgang)}
TRANSITION pcg.t.STRETCH+
CONSUME pcg.p.STRETCH: 1, pcg.p.pegel_STRETCH_0: 1;
PRODUCE pcg.p.n_STRETCH: 1, pcg.p.pegel_STRETCH_1: 1;

TRANSITION pcg.t.STRETCH-
CONSUME pcg.p.STRETCH: 1, pcg.p.pegel_STRETCH_1: 1;
PRODUCE pcg.p.n_STRETCH: 1, pcg.p.pegel_STRETCH_0: 1;



{Output Port}


{Pegelkodierung: (INT_CLK, DATAV_OUT)}

{INT_CLK+ bei DATAV_OUT=0 erzeugt DONV+}
TRANSITION op.t.INT_CLK_1_pegel_0_0
CONSUME op.p.INT_CLK: 1, op.p.pegel_INT_CLK_0: 1, lsm.p.pegel_DATAV_OUT_0: 1,
        op.oc.p.n_DONV+: 1;
PRODUCE op.p.n_INT_CLK: 1, op.p.pegel_INT_CLK_1: 1, lsm.p.pegel_DATAV_OUT_0: 1,
        op.oc.p.DONV+: 1;

{INT_CLK+ bei DATAV_OUT=1 erzeugt DOV+}
TRANSITION op.t.INT_CLK_1_pegel_0_1
CONSUME op.p.INT_CLK: 1, op.p.pegel_INT_CLK_0: 1, lsm.p.pegel_DATAV_OUT_1: 1,
        op.oc.p.n_DOV+: 1;
PRODUCE op.p.n_INT_CLK: 1, op.p.pegel_INT_CLK_1: 1, lsm.p.pegel_DATAV_OUT_1: 1,
        op.oc.p.DOV+: 1;

{INT_CLK- erzeugt DOV- bzw. DONV-}
TRANSITION op.t.INT_CLK_0_pegel_1_x
CONSUME op.p.INT_CLK: 1, op.p.pegel_INT_CLK_1: 1, op.oc.p.n_DOVDONV-: 1;
PRODUCE op.p.n_INT_CLK: 1, op.p.pegel_INT_CLK_0: 1, op.oc.p.DOVDONV-: 1;


{Output Controller im OP}

TRANSITION op.oc.t.01
CONSUME op.oc.p.0: 1, op.oc.p.DOV+: 1, pcg.p.n_STRETCH: 1,
        ip.ic.p.n_ACKC: 1, ip.p.n_ACKC+: 1;
PRODUCE op.oc.p.1: 1, op.oc.p.n_DOV+: 1, pcg.p.STRETCH: 1,
        ip.ic.p.ACKC: 1, ip.p.ACKC+: 1;

TRANSITION op.oc.t.03
CONSUME op.oc.p.0: 1, op.oc.p.DONV+: 1, ip.ic.p.n_ACKC: 1,
        ip.p.n_ACKC+: 1;
PRODUCE op.oc.p.3: 1, op.oc.p.n_DONV+: 1, ip.ic.p.ACKC: 1,
        ip.p.ACKC+: 1;

TRANSITION op.oc.t.12
CONSUME op.oc.p.1: 1, op.oc.p.DOVDONV-: 1, pcg.p.n_STRETCH: 1,
        ip.ic.p.n_ACKC: 1, cc.p.n_ACK_INT: 1;
PRODUCE op.oc.p.2: 1, op.oc.p.n_DOVDONV-: 1, pcg.p.STRETCH: 1,
        ip.ic.p.ACKC: 1, cc.p.ACK_INT: 1;

TRANSITION op.oc.t.21
CONSUME op.oc.p.2: 1, op.oc.p.DOV+: 1, pcg.p.n_STRETCH: 1,
        ip.ic.p.n_ACKC: 1, ip.p.n_ACKC+: 1;
PRODUCE op.oc.p.1: 1, op.oc.p.n_DOV+: 1, pcg.p.STRETCH: 1,
        ip.ic.p.ACKC: 1, ip.p.ACKC+: 1;

TRANSITION op.oc.t.23
CONSUME op.oc.p.2: 1, op.oc.p.DONV+: 1, ip.ic.p.n_ACKC: 1,
        ip.p.n_ACKC+: 1;
PRODUCE op.oc.p.3: 1, op.oc.p.n_DONV+: 1, ip.ic.p.ACKC: 1,
        ip.p.ACKC+: 1;

TRANSITION op.oc.t.30
CONSUME op.oc.p.3: 1, op.oc.p.DOVDONV-: 1, ip.ic.p.n_ACKC: 1,
        cc.p.n_ACK_INT: 1;
PRODUCE op.oc.p.0: 1, op.oc.p.n_DOVDONV-: 1, ip.ic.p.ACKC: 1,
        cc.p.ACK_INT: 1;


{AND im Wrapper}

TRANSITION and_no_LCLKM
CONSUME and.p.LCLK: 1, tog.p.pegel_ST_0: 1;
PRODUCE and.p.n_LCLK: 1, tog.p.pegel_ST_0: 1;

TRANSITION and_LCLKM-
CONSUME and.p.LCLK: 1, tog.p.pegel_ST_1: 1, pcg.p.pegel_LCLK_0: 1,
        op.p.n_INT_CLK: 1;
PRODUCE and.p.n_LCLK: 1, tog.p.pegel_ST_1: 1, pcg.p.pegel_LCLK_0: 1,
        op.p.INT_CLK: 1;

TRANSITION and_LCLKM+
CONSUME and.p.LCLK: 1, tog.p.pegel_ST_1: 1, pcg.p.pegel_LCLK_1: 1, ip.p.n_LCLKM: 1,
        op.p.n_INT_CLK: 1;
PRODUCE and.p.n_LCLK: 1, tog.p.pegel_ST_1: 1, pcg.p.pegel_LCLK_1: 1, ip.p.LCLKM: 1,
        op.p.INT_CLK: 1;




