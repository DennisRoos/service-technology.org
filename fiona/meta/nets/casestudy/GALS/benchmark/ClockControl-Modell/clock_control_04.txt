{Clock Control des zweiten GALS-Wrappers}

{01: konkret, unreduziert}
{02: Alle Bauteile zu einem Modul verschmolzen}
{03: Einzelner Pegelplatz kodiert nicht mehr Pegel für alle Signale, sondern}
{    jeweils zwei Plätze kodieren Pegel für ein Signal}
{04: abstrahiert}

PLACE
    cc.p.ST,  {Input-Flanken}
    cc.p.n_ST,
    cc.p.ACK_INT,
    cc.p.n_ACK_INT,
    cc.p.RST,
    cc.p.n_RST,
    cc.p.REQ_INT,
    cc.p.n_REQ_INT,
    cc.p.STOPH,  {Output-Flanken}
    cc.p.n_STOPH,
    cc.p.STOPI,
    cc.p.n_STOPI,
    cc.p.pegel_ST_0,
    cc.p.pegel_ST_1,
    cc.p.pegel_ACK_INT_0,
    cc.p.pegel_ACK_INT_1,
    cc.p.pegel_REQ_INT_0,
    cc.p.pegel_REQ_INT_1,
    cc.p.pegel_STOPH_0,
    cc.p.pegel_STOPH_1,
    cc.p.pegel_STOPI_0,
    cc.p.pegel_STOPI_1,
    {Clock Control muss manchmal Zustand des Input Controllers kennen.}
    {Deshalb hier folgender Hilfsplatz.}
    ip.ic.p.4,  {bei Einbau in Wrapper entfernen!}
    {STOPH darf nicht produziert werden, wenn IC über 5 nach 0 geht.}
    cc.p.erlaube_stop; {bei Einbau in Wrapper IC entsprechend modifizieren}

MARKING
    cc.p.n_ST: 1,
    cc.p.n_ACK_INT: 1,
    cc.p.n_RST: 1,
    cc.p.n_REQ_INT: 1,
    cc.p.n_STOPH: 1,
    cc.p.n_STOPI: 1,
    cc.p.pegel_ST_0: 1,
    cc.p.pegel_ACK_INT_0: 1,
    cc.p.pegel_REQ_INT_0: 1,
    cc.p.pegel_STOPH_0: 1,
    cc.p.pegel_STOPI_1: 1, {STOPI mit 1 initialisiert}
    ip.ic.p.4: 1, {bei Einbau in Wrapper entfernen!}
    cc.p.erlaube_stop: 1;


TRANSITION cc.t.ST_1_ignorieren
CONSUME cc.p.ST: 1, cc.p.pegel_ST_0: 1;
PRODUCE cc.p.n_ST: 1, cc.p.pegel_ST_1: 1; 

TRANSITION cc.t.ST_0_ignorieren
CONSUME cc.p.ST: 1, cc.p.pegel_ST_1: 1;
PRODUCE cc.p.n_ST: 1, cc.p.pegel_ST_0: 1; 


TRANSITION cc.t.ACK_INT_1_ignorieren
CONSUME cc.p.ACK_INT: 1, cc.p.pegel_ACK_INT_0: 1;
PRODUCE cc.p.n_ACK_INT: 1, cc.p.pegel_ACK_INT_1: 1; 

TRANSITION cc.t.ACK_INT_0_ignorieren
CONSUME cc.p.ACK_INT: 1, cc.p.pegel_ACK_INT_1: 1;
PRODUCE cc.p.n_ACK_INT: 1, cc.p.pegel_ACK_INT_0: 1; 


TRANSITION cc.t.counter_erreicht_max
CONSUME cc.p.ST: 1, cc.p.ACK_INT: 1, cc.p.pegel_ST_0: 1,
        cc.p.pegel_ACK_INT_1: 1, cc.p.pegel_STOPH_0: 1, cc.p.pegel_STOPI_0: 1,
        cc.p.erlaube_stop: 1, cc.p.n_STOPH: 1, cc.p.n_STOPI: 1;
PRODUCE cc.p.n_ST: 1, cc.p.n_ACK_INT: 1, cc.p.pegel_ST_1: 1,
        cc.p.pegel_ACK_INT_0: 1, cc.p.pegel_STOPH_1: 1, cc.p.pegel_STOPI_1: 1,
        cc.p.erlaube_stop: 1, cc.p.STOPH: 1, cc.p.STOPI: 1;


TRANSITION cc.t.RST_keine_stoph_flanke
CONSUME cc.p.RST: 1, cc.p.pegel_STOPH_0: 1;
PRODUCE cc.p.n_RST: 1, cc.p.pegel_STOPH_0: 1;

TRANSITION cc.t.RST_stoph_flanke
CONSUME cc.p.RST: 1, ip.ic.p.4: 1, cc.p.pegel_STOPH_1: 1, cc.p.n_STOPH: 1;
PRODUCE cc.p.n_RST: 1, ip.ic.p.4: 1, cc.p.pegel_STOPH_0: 1, cc.p.STOPH: 1;


TRANSITION cc.t.REQ_INT_0
CONSUME cc.p.REQ_INT: 1, cc.p.pegel_REQ_INT_1: 1;
PRODUCE cc.p.n_REQ_INT: 1, cc.p.pegel_REQ_INT_0: 1;

TRANSITION cc.t.REQ_INT_1_pegel_STOPI_0
CONSUME cc.p.REQ_INT: 1, cc.p.pegel_REQ_INT_0: 1, cc.p.pegel_STOPI_0: 1;
PRODUCE cc.p.n_REQ_INT: 1, cc.p.pegel_REQ_INT_1: 1, cc.p.pegel_STOPI_0: 1;

TRANSITION cc.t.REQ_INT_1_pegel_STOPI_1
CONSUME cc.p.REQ_INT: 1, cc.p.pegel_REQ_INT_0: 1, cc.p.pegel_STOPI_1: 1,
        cc.p.n_STOPI: 1;
PRODUCE cc.p.n_REQ_INT: 1, cc.p.pegel_REQ_INT_1: 1, cc.p.pegel_STOPI_0: 1,
        cc.p.STOPI: 1;



{Anbindung an Außenwelt}

{ST produzieren}
TRANSITION cc.t.ST
CONSUME cc.p.n_ST: 1;
PRODUCE cc.p.ST: 1;

{ACK_INT produzieren}
TRANSITION cc.t.ACK_INT
CONSUME cc.p.n_ACK_INT: 1;
PRODUCE cc.p.ACK_INT: 1;

{RST produzieren}
TRANSITION cc.t.RST
CONSUME cc.p.n_RST: 1;
PRODUCE cc.p.RST: 1;

{REQ_INT produzieren}
TRANSITION cc.t.REQ_INT
CONSUME cc.p.n_REQ_INT: 1;
PRODUCE cc.p.REQ_INT: 1;

{STOPH abräumen}
TRANSITION cc.t.STOPH
CONSUME cc.p.STOPH: 1;
PRODUCE cc.p.n_STOPH: 1;

{STOPI abräumen}
TRANSITION cc.t.STOPI
CONSUME cc.p.STOPI: 1;
PRODUCE cc.p.n_STOPI: 1;



{ vim: set ft=lola: }
