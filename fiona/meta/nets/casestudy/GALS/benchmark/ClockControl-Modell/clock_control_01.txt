{Clock Control des zweiten GALS-Wrappers}

PLACE
    {AND im CC}
    cc.and.p.ST,  {a}  {Input-Flanken}
    cc.and.p.n_ST,  {n_a}
    cc.and.p.ACK_INT,  {b}
    cc.and.p.n_ACK_INT,  {n_b}
    {cc.and.p.out => cc.counter.clk}  {Output-Flanke}
    cc.and.p.pegel_0_0,      {alte Pegel}
    cc.and.p.pegel_0_1,
    cc.and.p.pegel_1_0,
    cc.and.p.pegel_1_1,

    {Counter im CC}
    cc.counter.p.clk,  {Input-Flanke}
    cc.counter.p.n_clk,
    cc.counter.p.RST,  {rst}
    cc.counter.p.n_RST,  {rst}
    cc.counter.p.STOPH,  {out}  {Verzweigung: cc.ff.p.STOPH}  {Output-Flanke}
    cc.counter.p.n_STOPH,  {n_out}  {Verzweigung: cc.ff.p.n_STOPH}
    cc.counter.p.pegel_0_0_0,  {Pegel: (clk, rst, out)}
    cc.counter.p.pegel_0_0_1,  {Pegel (0,1,1) und (1,1,1) existieren nicht,}
    cc.counter.p.pegel_0_1_0,  {weil rst=1 immer out=0 setzt}
    cc.counter.p.pegel_1_0_0,
    cc.counter.p.pegel_1_0_1,
    cc.counter.p.pegel_1_1_0,

    {D1-FF im CC}
    cc.ff.p.STOPH,  {clk}  {Input-Flanke}
    cc.ff.p.n_STOPH,  {n_clk}
    cc.ff.p.REQ_INT,  {rst}
    cc.ff.p.n_REQ_INT,  {n_rst}
    cc.ff.p.STOPI,  {q}  {Output-Flanke}
    cc.ff.p.n_STOPI,  {n_q}
    cc.ff.p.pegel_0_0_0,  {Pegel: (clk, rst, q)}
    cc.ff.p.pegel_0_0_1,
    cc.ff.p.pegel_0_1_0,
    cc.ff.p.pegel_1_0_0,
    cc.ff.p.pegel_1_0_1,
    cc.ff.p.pegel_1_1_0;

MARKING
    cc.and.p.n_ST: 1,
    cc.and.p.n_ACK_INT: 1,
    cc.and.p.pegel_0_0: 1,

    cc.counter.p.n_clk: 1,
    cc.counter.p.n_RST: 1,
    cc.counter.p.n_STOPH: 1,
    cc.counter.p.pegel_1_0_0: 1,  {clk-Eingang ist negiert}

    cc.ff.p.n_STOPH: 1,
    cc.ff.p.n_REQ_INT: 1,
    cc.ff.p.n_STOPI: 1,
    cc.ff.p.pegel_0_0_1: 1;  {D-FF ist mit 1 initialisiert (STOPI=1)}



{AND im CC}

TRANSITION cc.and.t.a1_pegel_0_0
CONSUME cc.and.p.ST: 1, cc.and.p.pegel_0_0: 1;
PRODUCE cc.and.p.pegel_1_0: 1, cc.and.p.n_ST: 1;

TRANSITION cc.and.t.a1_pegel_0_1
CONSUME cc.and.p.ST: 1, cc.and.p.pegel_0_1: 1, cc.counter.p.n_clk: 1;
PRODUCE cc.and.p.pegel_1_1: 1, cc.counter.p.clk: 1, cc.and.p.n_ST: 1;

TRANSITION cc.and.t.a0_pegel_1_0
CONSUME cc.and.p.ST: 1, cc.and.p.pegel_1_0: 1;
PRODUCE cc.and.p.pegel_0_0: 1, cc.and.p.n_ST: 1;

TRANSITION cc.and.t.a0_pegel_1_1
CONSUME cc.and.p.ST: 1, cc.and.p.pegel_1_1: 1, cc.counter.p.n_clk: 1;
PRODUCE cc.and.p.pegel_0_1: 1, cc.counter.p.clk: 1, cc.and.p.n_ST: 1;


TRANSITION cc.and.t.b1_pegel_0_0
CONSUME cc.and.p.ACK_INT: 1, cc.and.p.pegel_0_0: 1;
PRODUCE cc.and.p.pegel_0_1: 1, cc.and.p.n_ACK_INT: 1;

TRANSITION cc.and.t.b0_pegel_0_1
CONSUME cc.and.p.ACK_INT: 1, cc.and.p.pegel_0_1: 1;
PRODUCE cc.and.p.pegel_0_0: 1, cc.and.p.n_ACK_INT: 1;

TRANSITION cc.and.t.b1_pegel_1_0
CONSUME cc.and.p.ACK_INT: 1, cc.and.p.pegel_1_0: 1, cc.counter.p.n_clk: 1;
PRODUCE cc.and.p.pegel_1_1: 1, cc.counter.p.clk: 1, cc.and.p.n_ACK_INT: 1;

TRANSITION cc.and.t.b0_pegel_1_1
CONSUME cc.and.p.ACK_INT: 1, cc.and.p.pegel_1_1: 1, cc.counter.p.n_clk: 1;
PRODUCE cc.and.p.pegel_1_0: 1, cc.counter.p.clk: 1, cc.and.p.n_ACK_INT: 1;



{Counter im CC}

TRANSITION cc.counter.t.clk1_pegel_0_0_0
CONSUME cc.counter.p.clk: 1, cc.counter.p.pegel_0_0_0: 1,
        cc.counter.p.n_STOPH: 1, cc.ff.p.n_STOPH: 1;
PRODUCE cc.counter.p.pegel_1_0_1: 1, cc.counter.p.STOPH: 1, cc.ff.p.STOPH: 1,
        cc.counter.p.n_clk: 1;

TRANSITION cc.counter.t.clk1_pegel_0_0_1
CONSUME cc.counter.p.clk: 1, cc.counter.p.pegel_0_0_1: 1;
PRODUCE cc.counter.p.pegel_1_0_1: 1, cc.counter.p.n_clk: 1;

TRANSITION cc.counter.t.clk1_pegel_0_1_0
CONSUME cc.counter.p.clk: 1, cc.counter.p.pegel_0_1_0: 1;
PRODUCE cc.counter.p.pegel_1_1_0: 1, cc.counter.p.n_clk: 1;

TRANSITION cc.counter.t.clk0_pegel_1_0_0
CONSUME cc.counter.p.clk: 1, cc.counter.p.pegel_1_0_0: 1;
PRODUCE cc.counter.p.pegel_0_0_0: 1, cc.counter.p.n_clk: 1;

TRANSITION cc.counter.t.clk0_pegel_1_0_1
CONSUME cc.counter.p.clk: 1, cc.counter.p.pegel_1_0_1: 1;
PRODUCE cc.counter.p.pegel_0_0_1: 1, cc.counter.p.n_clk: 1;

TRANSITION cc.counter.t.clk0_pegel_1_1_0
CONSUME cc.counter.p.clk: 1, cc.counter.p.pegel_1_1_0: 1;
PRODUCE cc.counter.p.pegel_0_1_0: 1, cc.counter.p.n_clk: 1;


TRANSITION cc.counter.t.rst1_pegel_0_0_0
CONSUME cc.counter.p.RST: 1, cc.counter.p.pegel_0_0_0: 1;
PRODUCE cc.counter.p.pegel_0_1_0: 1, cc.counter.p.n_RST: 1;

TRANSITION cc.counter.t.rst1_pegel_0_0_1
CONSUME cc.counter.p.RST: 1, cc.counter.p.pegel_0_0_1: 1,
        cc.counter.p.n_STOPH: 1, cc.ff.p.n_STOPH: 1;
PRODUCE cc.counter.p.pegel_0_1_0: 1, cc.counter.p.STOPH: 1, cc.ff.p.STOPH: 1,
        cc.counter.p.n_RST: 1;

TRANSITION cc.counter.t.rst0_pegel_0_1_0
CONSUME cc.counter.p.RST: 1, cc.counter.p.pegel_0_1_0: 1;
PRODUCE cc.counter.p.pegel_0_0_0: 1, cc.counter.p.n_RST: 1;

TRANSITION cc.counter.t.rst1_pegel_1_0_0
CONSUME cc.counter.p.RST: 1, cc.counter.p.pegel_1_0_0: 1;
PRODUCE cc.counter.p.pegel_1_1_0: 1, cc.counter.p.n_RST: 1;

TRANSITION cc.counter.t.rst1_pegel_1_0_1
CONSUME cc.counter.p.RST: 1, cc.counter.p.pegel_1_0_1: 1,
        cc.counter.p.n_STOPH: 1, cc.ff.p.n_STOPH: 1;
PRODUCE cc.counter.p.pegel_1_1_0: 1, cc.counter.p.STOPH: 1, cc.ff.p.STOPH: 1,
        cc.counter.p.n_RST: 1;

TRANSITION cc.counter.t.rst0_pegel_1_1_0
CONSUME cc.counter.p.RST: 1, cc.counter.p.pegel_1_1_0: 1;
PRODUCE cc.counter.p.pegel_1_0_0: 1, cc.counter.p.n_RST: 1;



{D1-FF im CC}

TRANSITION cc.ff.t.clk0_1_0_0
CONSUME cc.ff.p.STOPH: 1, cc.ff.p.pegel_1_0_0: 1;
PRODUCE cc.ff.p.pegel_0_0_0: 1, cc.ff.p.n_STOPH: 1;

TRANSITION cc.ff.t.clk0_1_0_1
CONSUME cc.ff.p.STOPH: 1, cc.ff.p.pegel_1_0_1: 1;
PRODUCE cc.ff.p.pegel_0_0_1: 1, cc.ff.p.n_STOPH: 1;

TRANSITION cc.ff.t.clk0_1_1_0
CONSUME cc.ff.p.STOPH: 1, cc.ff.p.pegel_1_1_0: 1;
PRODUCE cc.ff.p.pegel_0_1_0: 1, cc.ff.p.n_STOPH: 1;

TRANSITION cc.ff.t.clk1_0_0_0
CONSUME cc.ff.p.STOPH: 1, cc.ff.p.pegel_0_0_0: 1, cc.ff.p.n_STOPI: 1;
PRODUCE cc.ff.p.pegel_1_0_1: 1, cc.ff.p.STOPI: 1, cc.ff.p.n_STOPH: 1;

TRANSITION cc.ff.t.clk1_0_0_1
CONSUME cc.ff.p.STOPH: 1, cc.ff.p.pegel_0_0_1: 1;
PRODUCE cc.ff.p.pegel_1_0_1: 1, cc.ff.p.n_STOPH: 1;

TRANSITION cc.ff.t.clk1_0_1_0
CONSUME cc.ff.p.STOPH: 1, cc.ff.p.pegel_0_1_0: 1;
PRODUCE cc.ff.p.pegel_1_1_0: 1, cc.ff.p.n_STOPH: 1;


TRANSITION cc.ff.t.rst0_0_1_0
CONSUME cc.ff.p.REQ_INT: 1, cc.ff.p.pegel_0_1_0: 1;
PRODUCE cc.ff.p.pegel_0_0_0: 1, cc.ff.p.n_REQ_INT: 1;

TRANSITION cc.ff.t.rst0_1_1_0
CONSUME cc.ff.p.REQ_INT: 1, cc.ff.p.pegel_1_1_0: 1;
PRODUCE cc.ff.p.pegel_1_0_0: 1, cc.ff.p.n_REQ_INT: 1;

TRANSITION cc.ff.t.rst1_1_0_0
CONSUME cc.ff.p.REQ_INT: 1, cc.ff.p.pegel_1_0_0: 1;
PRODUCE cc.ff.p.pegel_1_1_0: 1, cc.ff.p.n_REQ_INT: 1;

TRANSITION cc.ff.t.rst1_1_0_1
CONSUME cc.ff.p.REQ_INT: 1, cc.ff.p.pegel_1_0_1: 1, cc.ff.p.n_STOPI: 1;
PRODUCE cc.ff.p.pegel_1_1_0: 1, cc.ff.p.STOPI: 1, cc.ff.p.n_REQ_INT: 1;

TRANSITION cc.ff.t.rst1_0_0_0
CONSUME cc.ff.p.REQ_INT: 1, cc.ff.p.pegel_0_0_0: 1;
PRODUCE cc.ff.p.pegel_0_1_0: 1, cc.ff.p.n_REQ_INT: 1;

TRANSITION cc.ff.t.rst1_0_0_1
CONSUME cc.ff.p.REQ_INT: 1, cc.ff.p.pegel_0_0_1: 1, cc.ff.p.n_STOPI: 1;
PRODUCE cc.ff.p.pegel_0_1_0: 1, cc.ff.p.STOPI: 1, cc.ff.p.n_REQ_INT: 1;



{Anbindung an Auﬂenwelt}

{ST produzieren}
TRANSITION cc.t.ST
CONSUME cc.and.p.n_ST: 1;
PRODUCE cc.and.p.ST: 1;

{ACK_INT produzieren}
TRANSITION cc.t.ACK_INT
CONSUME cc.and.p.n_ACK_INT: 1;
PRODUCE cc.and.p.ACK_INT: 1;

{RST produzieren}
TRANSITION cc.t.RST
CONSUME cc.counter.p.n_RST: 1;
PRODUCE cc.counter.p.RST: 1;

{REQ_INT produzieren}
TRANSITION cc.t.REQ_INT
CONSUME cc.ff.p.n_REQ_INT: 1;
PRODUCE cc.ff.p.REQ_INT: 1;

{STOPH abr‰umen}
TRANSITION cc.t.STOPH
CONSUME cc.counter.p.STOPH: 1;
PRODUCE cc.counter.p.n_STOPH: 1;

{STOPI abr‰umen}
TRANSITION cc.t.STOPI
CONSUME cc.ff.p.STOPI: 1;
PRODUCE cc.ff.p.n_STOPI: 1;



{ vim: set ft=lola: }
