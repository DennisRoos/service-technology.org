SORT

colors    = [ 1 , 6 ] ;
positions = [ 1 , 4 ] ;


{ which color is at which position }
pair = RECORD
    c : colors;
    p : positions;
END;


{ create a multiset of elements of each color }
FUNCTION allColors() : colors
    VAR x : colors;
BEGIN 
    FOR ALL x
        DO RETURN x
    END
END


{ create a multiset of elements of each position }
FUNCTION allPositions():positions
    VAR x : positions;
BEGIN 
    FOR ALL x DO
        RETURN x
    END
END


{ typecast from color/position to a pair }
FUNCTION X(x : colors; y : positions) : pair
    VAR r : pair;
BEGIN
    r . c = x;
    r . p = y;
    RETURN r
END



PLACE

controlStart,

 { the number of attempts }
countAttempts,
 { the code to be guessed }
theCode : pair,

 { colors not used in the set code }
availableColors : colors,
 { positions not used in the set code }
availablePositions : positions,

 { the current input guess }
in_attempt : pair,
 { internal copy of in_attempt }
attempt : pair,
 { complement place for attempt }
c_attempt : pair,

 { output: number of black/red/white tokens }
out_black,
out_red,
out_white,

 { internal copies of the output (to be able to trigger complete output) }
red,
black,
white,

 { deadlock state to model input error }
bad,

 { control places to model protocol }
controlMatched,
controlOutput,
controlFinishedround,
controlExpectinput,

 { the winning strategy! }
controlFinal,

 { you won :-) }
out_win;




MARKING

 { 4 token on start place: ... }
controlStart : 4,

 { you have 6 tries }
countAttempts : 6,

availableColors : allColors(),
availablePositions : allPositions(),

c_attempt : X(allColors(), allPositions());




{ service creates the code to be guessed (fires 4 times) }
TRANSITION createCode
VAR c : colors;
    p : positions;
CONSUME
    controlStart : 1,
    availableColors : c,
    availablePositions : p;
PRODUCE 
    theCode : X(c,p),
    controlExpectinput: 1;



{ check integrity of input: a guess must not have a position twice }
TRANSITION checkDoublePosition
VAR c, cc : colors;
    p : positions;
CONSUME
    attempt : X(c,p) + X(cc,p),
    countAttempts : 1;
PRODUCE 
    bad : 1,
    c_attempt : X(c,p) + X(cc,p);


{ check integrity of input: a guess must not have a color twice  }
TRANSITION checkDoubleColor
VAR c : colors;
    p, pp : positions;
CONSUME
    attempt : X(c,p) + X(c,pp),
    countAttempts : 1;
PRODUCE
    bad : 1,
    c_attempt : X(c,p) + X(c,pp);


{ how many black pins can we return }
TRANSITION evaluateBlack
VAR p : pair;
CONSUME
    theCode : p,
    attempt : p,
    controlExpectinput : 1;
PRODUCE
    theCode : p,
    black : 1,
    controlMatched : 1,
    c_attempt : p;


{ how many red pins can we return }
TRANSITION evaluateRed
VAR c : colors;
    p , pp : positions;
GUARD p # pp
CONSUME
    theCode : X(c,p),
    attempt : X(c,pp),
    controlExpectinput : 1;
PRODUCE
    theCode : X(c,p),
    red : 1,
    controlMatched : 1,
    c_attempt : X(c,pp);


{ how many white pins can we return }
TRANSITION evaluateWhite
VAR c : colors;
    p : positions;
CONSUME
    attempt: X(c,p),
    availableColors : c,
    controlExpectinput : 1;
PRODUCE 
    availableColors : c,
    controlMatched : 1,
    white : 1,
    c_attempt: X(c,p);


{ you won! }
TRANSITION reportWin
CONSUME controlMatched : 4, black : 4;
PRODUCE out_win : 1, controlFinal : 1;


{ you did not win (yet): at least one red pin }
TRANSITION startoutput1
CONSUME controlMatched : 4, red : 1;
PRODUCE controlOutput : 4, red : 1;


{ you did not win (yet): at least one white pin }
TRANSITION startoutput2
CONSUME controlMatched: 4, white : 1;
PRODUCE controlOutput : 4, white : 1;


{ return a black pin }
TRANSITION outblack
CONSUME controlOutput : 1, black : 1;
PRODUCE out_black :1, controlFinishedround : 1;


{ return a red pin }
TRANSITION outred
CONSUME controlOutput : 1, red : 1;
PRODUCE controlFinishedround : 1, out_red : 1;


{ return a white pin }
TRANSITION outwhite
CONSUME controlOutput : 1, white : 1;
PRODUCE controlFinishedround : 1, out_white : 1;


{ try again }
TRANSITION resume
CONSUME controlFinishedround : 4, countAttempts : 1;
PRODUCE controlExpectinput : 4;


{ from input place to internal copy }
TRANSITION inbox
VAR p : pair;
CONSUME
    in_attempt : p,
    c_attempt : p;
PRODUCE
    attempt : p;
