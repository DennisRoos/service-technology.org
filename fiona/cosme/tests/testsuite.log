## --------------------- ##
## Cosme 0.7 test suite. ##
## --------------------- ##

testsuite: command line was:
  $ ./testsuite 

## ----------- ##
## ChangeLogs. ##
## ----------- ##

testsuite: ../ChangeLog:

## --------- ##
## Platform. ##
## --------- ##

hostname = SomTam
uname -m = x86_64
uname -r = 2.6.32-22-generic
uname -s = Linux
uname -v = #33-Ubuntu SMP Wed Apr 28 13:28:05 UTC 2010

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /home/jeed/workspace/cosme/tests
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin
PATH: /usr/games

testsuite: atconfig:
| # Configurable variable values for building test suites.
| # Generated by ./config.status.
| # Copyright (C) 2009 Free Software Foundation, Inc.
| 
| # The test suite will define top_srcdir=/../.. etc.
| at_testdir='tests'
| abs_builddir='/home/jeed/workspace/cosme/tests'
| at_srcdir='.'
| abs_srcdir='/home/jeed/workspace/cosme/tests'
| at_top_srcdir='..'
| abs_top_srcdir='/home/jeed/workspace/cosme'
| at_top_build_prefix='../'
| abs_top_builddir='/home/jeed/workspace/cosme'
| 
| # Backward compatibility with Autotest <= 2.59b:
| at_top_builddir=$at_top_build_prefix
| 
| AUTOTEST_PATH='tests'
| 
| SHELL=${CONFIG_SHELL-'/bin/bash'}

## ---------------- ##
## Tested programs. ##
## ---------------- ##

## ------------------ ##
## Running the tests. ##
## ------------------ ##
testsuite: starting at: Mon May 24 13:41:32 CEST 2010
1. Help output (testsuite.at:9): ok     (0m0.020s 0m0.020s)
2. Version output (testsuite.at:16): ok     (0m0.010s 0m0.000s)
3. Determining runtime and allocated memory (testsuite.at:25): ok     (0m0.050s 0m0.040s)
4. Results output (testsuite.at:34): ok     (0m0.040s 0m0.010s)
8. AP (testsuite.at:68): ok     (0m0.050s 0m0.010s)
9. auctionService (testsuite.at:75): ok     (0m0.000s 0m0.010s)
10. BH (testsuite.at:82): ok     (0m0.010s 0m0.010s)
11. CN (testsuite.at:89): ok     (0m0.030s 0m0.000s)
12. DG (testsuite.at:96): ok     (0m0.020s 0m0.020s)
13. loanApprovalProcess (testsuite.at:103): ok     (0m0.000s 0m0.030s)
14. myCoffee (testsuite.at:110): ok     (0m0.010s 0m0.030s)
15. phcontrol3.unf (testsuite.at:117): ok     (0m0.020s 0m0.000s)
16. PO (testsuite.at:124): ok     (0m0.010s 0m0.020s)
17. QR (testsuite.at:131): ok     (0m0.240s 0m0.020s)
18. RE (testsuite.at:138): ok     (0m0.010s 0m0.030s)
19. RS (testsuite.at:145): ok     (0m0.020s 0m0.020s)
20. TR (testsuite.at:152): ok     (0m0.030s 0m0.000s)
21. internal (testsuite.at:159): ok     (0m0.010s 0m0.020s)
22. internal_match (testsuite.at:166): ok     (0m0.020s 0m0.010s)
23. interface_match (testsuite.at:173): ok     (0m0.000s 0m0.010s)
24. SD (testsuite.at:180): ok     (0m0.000s 0m0.010s)
25. AP (testsuite.at:192): ok     (0m0.060s 0m0.010s)
26. BH (testsuite.at:199): ok     (0m0.000s 0m0.000s)
27. branch (testsuite.at:206): ok     (0m0.010s 0m0.000s)
28. CN (testsuite.at:213): ok     (0m0.020s 0m0.020s)
29. DG (testsuite.at:220): ok     (0m0.050s 0m0.020s)
30. DG-Ident (testsuite.at:227): ok     (0m0.040s 0m0.020s)
31. PO (testsuite.at:234): ok     (0m0.010s 0m0.020s)
32. simple (testsuite.at:241): ok     (0m0.000s 0m0.010s)
33. TR (testsuite.at:248): ok     (0m0.010s 0m0.000s)
34. branch vs. branch_compact (testsuite.at:255): ok     (0m0.010s 0m0.000s)
35. branch vs. branch_chopped (testsuite.at:262): ok     (0m0.000s 0m0.010s)
36. branch vs. branch_compact_extend (testsuite.at:269): ok     (0m0.010s 0m0.010s)
37. branch vs. branch_wrong_bits (testsuite.at:276): ok     (0m0.010s 0m0.000s)
38. AP vs. AP-pv (testsuite.at:288): ok     (0m0.080s 0m0.010s)
39. AP-pv vs. AP (testsuite.at:295): ok     (0m0.070s 0m0.010s)
40. AP-Ident (testsuite.at:302): ok     (0m0.060s 0m0.020s)
41. BH vs. BH-pv (testsuite.at:309): ok     (0m0.000s 0m0.030s)
42. BH-pv vs. BH (testsuite.at:316): ok     (0m0.010s 0m0.000s)
43. branch vs. branch_chopped (testsuite.at:323): ok     (0m0.010s 0m0.000s)
44. branch vs. branch_compact (testsuite.at:330): ok     (0m0.010s 0m0.020s)
45. branch_compact vs. branch (testsuite.at:337): ok     (0m0.000s 0m0.020s)
46. branch vs. branch_compact_extend (testsuite.at:344): ok     (0m0.000s 0m0.010s)
47. branch_chopped vs. branch_compact (testsuite.at:351): ok     (0m0.010s 0m0.030s)
48. CN vs. CN-pv (testsuite.at:358): ok     (0m0.020s 0m0.000s)
49. CN-pv vs. CN (testsuite.at:365): ok     (0m0.030s 0m0.000s)
50. DG vs. DG-pv (testsuite.at:372): ok     (0m0.050s 0m0.020s)
51. DG-pv vs. DG (testsuite.at:379): ok     (0m0.070s 0m0.000s)
52. PO vs. PO-pv (testsuite.at:386): ok     (0m0.010s 0m0.010s)
53. PO-pv vs. PO (testsuite.at:393): ok     (0m0.020s 0m0.000s)
54. simple vs. simple_smaller_interface (testsuite.at:400): ok     (0m0.000s 0m0.010s)
55. simple_smaller_interface vs. simple (testsuite.at:407): ok     (0m0.010s 0m0.000s)
56. TR vs. TR-pv (testsuite.at:414): ok     (0m0.010s 0m0.010s)
57. TR-pv vs. TR (testsuite.at:421): ok     (0m0.010s 0m0.010s)
58. branch vs. branch_chopped (testsuite.at:429): ok     (0m0.010s 0m0.000s)
59. branch_compact_extend vs. branch (testsuite.at:436): ok     (0m0.000s 0m0.010s)
60. branch vs. branch_wrong_bits (testsuite.at:443): ok     (0m0.010s 0m0.000s)
61. branch_wrong_bits vs. branch (testsuite.at:450): ok     (0m0.010s 0m0.000s)
62. branch_compact vs. branch_chopped (testsuite.at:457): ok     (0m0.000s 0m0.010s)
testsuite: ending at: Mon May 24 13:41:39 CEST 2010
testsuite: test suite duration: 0h 0m 7s

## ------------- ##
## Test results. ##
## ------------- ##

ERROR: All 62 tests were run,
3 failed unexpectedly.

## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##
Failed tests:
Cosme 0.7 test suite test groups:

 NUM: FILE-NAME:LINE     TEST-GROUP-NAME
      KEYWORDS

   5: testsuite.at:42    Checking for memory leaks (Matching)
   6: testsuite.at:49    Checking for memory leaks (Simulation)
   7: testsuite.at:56    Checking for memory leaks (Equivalence)

## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##

#                             -*- compilation -*-
5. testsuite.at:42: testing ...
./testsuite.at:43: cp /home/jeed/workspace/cosme/tests/testfiles/OGs/AP.bits.og /home/jeed/workspace/cosme/tests/testfiles/Services/AP-partner.owfn .
./testsuite.at:44: if test "/usr/local/bin/lola-statespace" == ""; then exit 77; fi
./testsuite.at:45: wrap.sh /usr/bin/valgrind --leak-check=full --show-reachable=yes /home/jeed/workspace/cosme/src/cosme --matching -a AP.bits.og -c AP-partner.owfn --finalize
stderr:
==8264== Memcheck, a memory error detector
==8264== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==8264== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==8264== Command: /home/jeed/workspace/cosme/src/cosme --matching -a AP.bits.og -c AP-partner.owfn --finalize
==8264== 
cosme: Matching: completed
==8264== Invalid read of size 4
==8264==    at 0x51EA12B: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8264==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x5928261: exit (exit.c:78)
==8264==    by 0x590DC53: (below main) (libc-start.c:258)
==8264==  Address 0x5c71670 is 16 bytes inside a block of size 34 free'd
==8264==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8264==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x5928261: exit (exit.c:78)
==8264==    by 0x590DC53: (below main) (libc-start.c:258)
==8264== 
==8264== Invalid write of size 4
==8264==    at 0x51EA131: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8264==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x5928261: exit (exit.c:78)
==8264==    by 0x590DC53: (below main) (libc-start.c:258)
==8264==  Address 0x5c71670 is 16 bytes inside a block of size 34 free'd
==8264==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8264==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x5928261: exit (exit.c:78)
==8264==    by 0x590DC53: (below main) (libc-start.c:258)
==8264== 
==8264== Invalid free() / delete / delete[]
==8264==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8264==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8264==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x5928261: exit (exit.c:78)
==8264==    by 0x590DC53: (below main) (libc-start.c:258)
==8264==  Address 0x5c71660 is 0 bytes inside a block of size 34 free'd
==8264==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8264==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x5928261: exit (exit.c:78)
==8264==    by 0x590DC53: (below main) (libc-start.c:258)
==8264== 
==8264== 
==8264== HEAP SUMMARY:
==8264==     in use at exit: 83 bytes in 2 blocks
==8264==   total heap usage: 62,638 allocs, 62,638 frees, 4,072,583 bytes allocated
==8264== 
==8264== 34 bytes in 1 blocks are definitely lost in loss record 1 of 2
==8264==    at 0x4C27CC1: operator new(unsigned long) (vg_replace_malloc.c:261)
==8264==    by 0x51E8D98: std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x51E98B4: ??? (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x51E9A52: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x4EFD7A6: global constructors keyed to petrinet.cc (petrinet.cc:216)
==8264==    by 0x4F12D15: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x4E6CD8A: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x7FF000467: ???
==8264==    by 0x736B726F772F6464: ???
==8264==    by 0x736F632F6563616F: ???
==8264==    by 0x632F6372732F656C: ???
==8264==    by 0x6D2D2D00656D736E: ???
==8264== 
==8264== 49 bytes in 1 blocks are definitely lost in loss record 2 of 2
==8264==    at 0x4C27CC1: operator new(unsigned long) (vg_replace_malloc.c:261)
==8264==    by 0x51E8D98: std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x51E98B4: ??? (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x51E9A52: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8264==    by 0x4EFD776: global constructors keyed to petrinet.cc (petrinet.cc:213)
==8264==    by 0x4F12D15: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x4E6CD8A: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8264==    by 0x7FF000467: ???
==8264==    by 0x736B726F772F6464: ???
==8264==    by 0x736F632F6563616F: ???
==8264==    by 0x632F6372732F656C: ???
==8264==    by 0x6D2D2D00656D736E: ???
==8264== 
==8264== LEAK SUMMARY:
==8264==    definitely lost: 83 bytes in 2 blocks
==8264==    indirectly lost: 0 bytes in 0 blocks
==8264==      possibly lost: 0 bytes in 0 blocks
==8264==    still reachable: 0 bytes in 0 blocks
==8264==         suppressed: 0 bytes in 0 blocks
==8264== 
==8264== For counts of detected and suppressed errors, rerun with: -v
==8264== ERROR SUMMARY: 8 errors from 5 contexts (suppressed: 4 from 4)
stdout:
./testsuite.at:46: /bin/grep -q "All heap blocks were freed -- no leaks are possible" stderr
./testsuite.at:46: exit code was 1, expected 0
5. testsuite.at:42: 5. Checking for memory leaks (Matching) (testsuite.at:42): FAILED (testsuite.at:46)

#                             -*- compilation -*-
6. testsuite.at:49: testing ...
./testsuite.at:50: cp /home/jeed/workspace/cosme/tests/testfiles/OGs/BH.bits.og .
./testsuite.at:51: if test "/usr/local/bin/lola-statespace" == ""; then exit 77; fi
./testsuite.at:52: wrap.sh /usr/bin/valgrind --leak-check=full --show-reachable=yes /home/jeed/workspace/cosme/src/cosme --simulation -a BH.bits.og -b BH.bits.og --finalize
stderr:
==8285== Memcheck, a memory error detector
==8285== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==8285== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==8285== Command: /home/jeed/workspace/cosme/src/cosme --simulation -a BH.bits.og -b BH.bits.og --finalize
==8285== 
cosme: Simulation: completed
==8285== Invalid read of size 4
==8285==    at 0x51EA12B: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8285==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x5928261: exit (exit.c:78)
==8285==    by 0x590DC53: (below main) (libc-start.c:258)
==8285==  Address 0x5c71670 is 16 bytes inside a block of size 34 free'd
==8285==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8285==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x5928261: exit (exit.c:78)
==8285==    by 0x590DC53: (below main) (libc-start.c:258)
==8285== 
==8285== Invalid write of size 4
==8285==    at 0x51EA131: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8285==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x5928261: exit (exit.c:78)
==8285==    by 0x590DC53: (below main) (libc-start.c:258)
==8285==  Address 0x5c71670 is 16 bytes inside a block of size 34 free'd
==8285==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8285==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x5928261: exit (exit.c:78)
==8285==    by 0x590DC53: (below main) (libc-start.c:258)
==8285== 
==8285== Invalid free() / delete / delete[]
==8285==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8285==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8285==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x5928261: exit (exit.c:78)
==8285==    by 0x590DC53: (below main) (libc-start.c:258)
==8285==  Address 0x5c71660 is 0 bytes inside a block of size 34 free'd
==8285==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8285==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x5928261: exit (exit.c:78)
==8285==    by 0x590DC53: (below main) (libc-start.c:258)
==8285== 
==8285== 
==8285== HEAP SUMMARY:
==8285==     in use at exit: 83 bytes in 2 blocks
==8285==   total heap usage: 5,250 allocs, 5,250 frees, 314,511 bytes allocated
==8285== 
==8285== 34 bytes in 1 blocks are definitely lost in loss record 1 of 2
==8285==    at 0x4C27CC1: operator new(unsigned long) (vg_replace_malloc.c:261)
==8285==    by 0x51E8D98: std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x51E98B4: ??? (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x51E9A52: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x4EFD7A6: global constructors keyed to petrinet.cc (petrinet.cc:216)
==8285==    by 0x4F12D15: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x4E6CD8A: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x7FF000467: ???
==8285==    by 0x736B726F772F6464: ???
==8285==    by 0x736F632F6563616F: ???
==8285==    by 0x632F6372732F656C: ???
==8285==    by 0x732D2D00656D736E: ???
==8285== 
==8285== 49 bytes in 1 blocks are definitely lost in loss record 2 of 2
==8285==    at 0x4C27CC1: operator new(unsigned long) (vg_replace_malloc.c:261)
==8285==    by 0x51E8D98: std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x51E98B4: ??? (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x51E9A52: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8285==    by 0x4EFD776: global constructors keyed to petrinet.cc (petrinet.cc:213)
==8285==    by 0x4F12D15: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x4E6CD8A: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8285==    by 0x7FF000467: ???
==8285==    by 0x736B726F772F6464: ???
==8285==    by 0x736F632F6563616F: ???
==8285==    by 0x632F6372732F656C: ???
==8285==    by 0x732D2D00656D736E: ???
==8285== 
==8285== LEAK SUMMARY:
==8285==    definitely lost: 83 bytes in 2 blocks
==8285==    indirectly lost: 0 bytes in 0 blocks
==8285==      possibly lost: 0 bytes in 0 blocks
==8285==    still reachable: 0 bytes in 0 blocks
==8285==         suppressed: 0 bytes in 0 blocks
==8285== 
==8285== For counts of detected and suppressed errors, rerun with: -v
==8285== ERROR SUMMARY: 8 errors from 5 contexts (suppressed: 4 from 4)
stdout:
./testsuite.at:53: /bin/grep -q "All heap blocks were freed -- no leaks are possible" stderr
./testsuite.at:53: exit code was 1, expected 0
6. testsuite.at:49: 6. Checking for memory leaks (Simulation) (testsuite.at:49): FAILED (testsuite.at:53)

#                             -*- compilation -*-
7. testsuite.at:56: testing ...
./testsuite.at:57: cp /home/jeed/workspace/cosme/tests/testfiles/OGs/BH.bits.og .
./testsuite.at:58: if test "/usr/local/bin/lola-statespace" == ""; then exit 77; fi
./testsuite.at:59: wrap.sh /usr/bin/valgrind --leak-check=full --show-reachable=yes /home/jeed/workspace/cosme/src/cosme --equivalence -a BH.bits.og -b BH.bits.og --finalize
stderr:
==8304== Memcheck, a memory error detector
==8304== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==8304== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==8304== Command: /home/jeed/workspace/cosme/src/cosme --equivalence -a BH.bits.og -b BH.bits.og --finalize
==8304== 
cosme: Equivalence: completed
==8304== Invalid read of size 4
==8304==    at 0x51EA12B: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8304==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x5928261: exit (exit.c:78)
==8304==    by 0x590DC53: (below main) (libc-start.c:258)
==8304==  Address 0x5c71670 is 16 bytes inside a block of size 34 free'd
==8304==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8304==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x5928261: exit (exit.c:78)
==8304==    by 0x590DC53: (below main) (libc-start.c:258)
==8304== 
==8304== Invalid write of size 4
==8304==    at 0x51EA131: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8304==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x5928261: exit (exit.c:78)
==8304==    by 0x590DC53: (below main) (libc-start.c:258)
==8304==  Address 0x5c71670 is 16 bytes inside a block of size 34 free'd
==8304==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8304==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x5928261: exit (exit.c:78)
==8304==    by 0x590DC53: (below main) (libc-start.c:258)
==8304== 
==8304== Invalid free() / delete / delete[]
==8304==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8304==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x592862F: __cxa_finalize (cxa_finalize.c:56)
==8304==    by 0x4E71605: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x4F12D30: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x5928261: exit (exit.c:78)
==8304==    by 0x590DC53: (below main) (libc-start.c:258)
==8304==  Address 0x5c71660 is 0 bytes inside a block of size 34 free'd
==8304==    at 0x4C26DCF: operator delete(void*) (vg_replace_malloc.c:387)
==8304==    by 0x51EA128: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x5928261: exit (exit.c:78)
==8304==    by 0x590DC53: (below main) (libc-start.c:258)
==8304== 
==8304== 
==8304== HEAP SUMMARY:
==8304==     in use at exit: 83 bytes in 2 blocks
==8304==   total heap usage: 5,250 allocs, 5,250 frees, 314,522 bytes allocated
==8304== 
==8304== 34 bytes in 1 blocks are definitely lost in loss record 1 of 2
==8304==    at 0x4C27CC1: operator new(unsigned long) (vg_replace_malloc.c:261)
==8304==    by 0x51E8D98: std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x51E98B4: ??? (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x51E9A52: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x4EFD7A6: global constructors keyed to petrinet.cc (petrinet.cc:216)
==8304==    by 0x4F12D15: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x4E6CD8A: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x7FF000467: ???
==8304==    by 0x736B726F772F6464: ???
==8304==    by 0x736F632F6563616F: ???
==8304==    by 0x632F6372732F656C: ???
==8304==    by 0x652D2D00656D736E: ???
==8304== 
==8304== 49 bytes in 1 blocks are definitely lost in loss record 2 of 2
==8304==    at 0x4C27CC1: operator new(unsigned long) (vg_replace_malloc.c:261)
==8304==    by 0x51E8D98: std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x51E98B4: ??? (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x51E9A52: std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.so.6.0.13)
==8304==    by 0x4EFD776: global constructors keyed to petrinet.cc (petrinet.cc:213)
==8304==    by 0x4F12D15: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x4E6CD8A: ??? (in /usr/local/lib/libpnapi.so.4.0.8)
==8304==    by 0x7FF000467: ???
==8304==    by 0x736B726F772F6464: ???
==8304==    by 0x736F632F6563616F: ???
==8304==    by 0x632F6372732F656C: ???
==8304==    by 0x652D2D00656D736E: ???
==8304== 
==8304== LEAK SUMMARY:
==8304==    definitely lost: 83 bytes in 2 blocks
==8304==    indirectly lost: 0 bytes in 0 blocks
==8304==      possibly lost: 0 bytes in 0 blocks
==8304==    still reachable: 0 bytes in 0 blocks
==8304==         suppressed: 0 bytes in 0 blocks
==8304== 
==8304== For counts of detected and suppressed errors, rerun with: -v
==8304== ERROR SUMMARY: 8 errors from 5 contexts (suppressed: 4 from 4)
stdout:
./testsuite.at:60: /bin/grep -q "All heap blocks were freed -- no leaks are possible" stderr
./testsuite.at:60: exit code was 1, expected 0
7. testsuite.at:56: 7. Checking for memory leaks (Equivalence) (testsuite.at:56): FAILED (testsuite.at:60)


## ------------- ##
## ../config.log ##
## ------------- ##
| This file contains any messages produced by compilers while
| running configure, to aid debugging if configure makes a mistake.
| 
| It was created by Cosme configure 0.7, which was
| generated by GNU Autoconf 2.65.  Invocation command line was
| 
|   $ ./configure 
| 
| ## --------- ##
| ## Platform. ##
| ## --------- ##
| 
| hostname = SomTam
| uname -m = x86_64
| uname -r = 2.6.32-22-generic
| uname -s = Linux
| uname -v = #33-Ubuntu SMP Wed Apr 28 13:28:05 UTC 2010
| 
| /usr/bin/uname -p = unknown
| /bin/uname -X     = unknown
| 
| /bin/arch              = unknown
| /usr/bin/arch -k       = unknown
| /usr/convex/getsysinfo = unknown
| /usr/bin/hostinfo      = unknown
| /bin/machine           = unknown
| /usr/bin/oslevel       = unknown
| /bin/universe          = unknown
| 
| PATH: /usr/local/sbin
| PATH: /usr/local/bin
| PATH: /usr/sbin
| PATH: /usr/bin
| PATH: /sbin
| PATH: /bin
| PATH: /usr/games
| 
| 
| ## ----------- ##
| ## Core tests. ##
| ## ----------- ##
| 
| configure:2259: checking for a BSD-compatible install
| configure:2327: result: /usr/bin/install -c
| configure:2338: checking whether build environment is sane
| configure:2388: result: yes
| configure:2529: checking for a thread-safe mkdir -p
| configure:2568: result: /bin/mkdir -p
| configure:2581: checking for gawk
| configure:2597: found /usr/bin/gawk
| configure:2608: result: gawk
| configure:2619: checking whether make sets $(MAKE)
| configure:2641: result: yes
| configure:2793: checking for g++
| configure:2809: found /usr/bin/g++
| configure:2820: result: g++
| configure:2847: checking for C++ compiler version
| configure:2856: g++ --version >&5
| g++ (Ubuntu 4.4.3-4ubuntu5) 4.4.3
| Copyright (C) 2009 Free Software Foundation, Inc.
| This is free software; see the source for copying conditions.  There is NO
| warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
| 
| configure:2867: $? = 0
| configure:2856: g++ -v >&5
| Using built-in specs.
| Target: x86_64-linux-gnu
| Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
| Thread model: posix
| gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5) 
| configure:2867: $? = 0
| configure:2856: g++ -V >&5
| g++: '-V' option must have argument
| configure:2867: $? = 1
| configure:2856: g++ -qversion >&5
| g++: unrecognized option '-qversion'
| g++: no input files
| configure:2867: $? = 1
| configure:2887: checking whether the C++ compiler works
| configure:2909: g++    conftest.cpp  >&5
| configure:2913: $? = 0
| configure:2962: result: yes
| configure:2965: checking for C++ compiler default output file name
| configure:2967: result: a.out
| configure:2973: checking for suffix of executables
| configure:2980: g++ -o conftest    conftest.cpp  >&5
| configure:2984: $? = 0
| configure:3006: result: 
| configure:3028: checking whether we are cross compiling
| configure:3036: g++ -o conftest    conftest.cpp  >&5
| configure:3040: $? = 0
| configure:3047: ./conftest
| configure:3051: $? = 0
| configure:3066: result: no
| configure:3071: checking for suffix of object files
| configure:3093: g++ -c   conftest.cpp >&5
| configure:3097: $? = 0
| configure:3118: result: o
| configure:3122: checking whether we are using the GNU C++ compiler
| configure:3141: g++ -c   conftest.cpp >&5
| configure:3141: $? = 0
| configure:3150: result: yes
| configure:3159: checking whether g++ accepts -g
| configure:3179: g++ -c -g  conftest.cpp >&5
| configure:3179: $? = 0
| configure:3220: result: yes
| configure:3254: checking for style of include used by make
| configure:3282: result: GNU
| configure:3307: checking dependency style of g++
| configure:3417: result: gcc3
| configure:3480: checking for gcc
| configure:3496: found /usr/bin/gcc
| configure:3507: result: gcc
| configure:3736: checking for C compiler version
| configure:3745: gcc --version >&5
| gcc (Ubuntu 4.4.3-4ubuntu5) 4.4.3
| Copyright (C) 2009 Free Software Foundation, Inc.
| This is free software; see the source for copying conditions.  There is NO
| warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
| 
| configure:3756: $? = 0
| configure:3745: gcc -v >&5
| Using built-in specs.
| Target: x86_64-linux-gnu
| Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
| Thread model: posix
| gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5) 
| configure:3756: $? = 0
| configure:3745: gcc -V >&5
| gcc: '-V' option must have argument
| configure:3756: $? = 1
| configure:3745: gcc -qversion >&5
| gcc: unrecognized option '-qversion'
| gcc: no input files
| configure:3756: $? = 1
| configure:3760: checking whether we are using the GNU C compiler
| configure:3779: gcc -c   conftest.c >&5
| configure:3779: $? = 0
| configure:3788: result: yes
| configure:3797: checking whether gcc accepts -g
| configure:3817: gcc -c -g  conftest.c >&5
| configure:3817: $? = 0
| configure:3858: result: yes
| configure:3875: checking for gcc option to accept ISO C89
| configure:3939: gcc  -c -g -O2  conftest.c >&5
| configure:3939: $? = 0
| configure:3952: result: none needed
| configure:3974: checking dependency style of gcc
| configure:4084: result: gcc3
| configure:4100: checking whether gcc and cc understand -c and -o together
| configure:4131: gcc -c conftest.c -o conftest2.o >&5
| configure:4135: $? = 0
| configure:4141: gcc -c conftest.c -o conftest2.o >&5
| configure:4145: $? = 0
| configure:4156: cc -c conftest.c >&5
| configure:4160: $? = 0
| configure:4168: cc -c conftest.c -o conftest2.o >&5
| configure:4172: $? = 0
| configure:4178: cc -c conftest.c -o conftest2.o >&5
| configure:4182: $? = 0
| configure:4200: result: yes
| configure:4230: checking for flex
| configure:4246: found /usr/bin/flex
| configure:4257: result: flex
| configure:4294: flex conftest.l
| configure:4298: $? = 0
| configure:4300: checking lex output file root
| configure:4314: result: lex.yy
| configure:4319: checking lex library
| configure:4333: gcc -o conftest -g -O2   conftest.c   >&5
| /tmp/ccTO17qC.o: In function `input':
| /home/jeed/workspace/cosme/lex.yy.c:1182: undefined reference to `yywrap'
| /tmp/ccTO17qC.o: In function `yylex':
| /home/jeed/workspace/cosme/lex.yy.c:881: undefined reference to `yywrap'
| /tmp/ccTO17qC.o: In function `main':
| /home/jeed/workspace/cosme/conftest.l:17: undefined reference to `yywrap'
| collect2: ld returned 1 exit status
| configure:4333: $? = 1
| configure: failed program was:
| | /* confdefs.h */
| | #define PACKAGE_NAME "Cosme"
| | #define PACKAGE_TARNAME "cosme"
| | #define PACKAGE_VERSION "0.7"
| | #define PACKAGE_STRING "Cosme 0.7"
| | #define PACKAGE_BUGREPORT "cosme@service-technology.org"
| | #define PACKAGE_URL "http://service-technology.org/cosme"
| | #define PACKAGE "cosme"
| | #define VERSION "0.7"
| | /* end confdefs.h.  */
| | 
| | #line 3 "lex.yy.c"
| | 
| | #define  YY_INT_ALIGNED short int
| | 
| | /* A lexical scanner generated by flex */
| | 
| | #define FLEX_SCANNER
| | #define YY_FLEX_MAJOR_VERSION 2
| | #define YY_FLEX_MINOR_VERSION 5
| | #define YY_FLEX_SUBMINOR_VERSION 35
| | #if YY_FLEX_SUBMINOR_VERSION > 0
| | #define FLEX_BETA
| | #endif
| | 
| | /* First, we deal with  platform-specific or compiler-specific issues. */
| | 
| | /* begin standard C headers. */
| | #include <stdio.h>
| | #include <string.h>
| | #include <errno.h>
| | #include <stdlib.h>
| | 
| | /* end standard C headers. */
| | 
| | /* flex integer type definitions */
| | 
| | #ifndef FLEXINT_H
| | #define FLEXINT_H
| | 
| | /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| | 
| | #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| | 
| | /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
| |  * if you want the limit (max/min) macros for int types. 
| |  */
| | #ifndef __STDC_LIMIT_MACROS
| | #define __STDC_LIMIT_MACROS 1
| | #endif
| | 
| | #include <inttypes.h>
| | typedef int8_t flex_int8_t;
| | typedef uint8_t flex_uint8_t;
| | typedef int16_t flex_int16_t;
| | typedef uint16_t flex_uint16_t;
| | typedef int32_t flex_int32_t;
| | typedef uint32_t flex_uint32_t;
| | #else
| | typedef signed char flex_int8_t;
| | typedef short int flex_int16_t;
| | typedef int flex_int32_t;
| | typedef unsigned char flex_uint8_t; 
| | typedef unsigned short int flex_uint16_t;
| | typedef unsigned int flex_uint32_t;
| | 
| | /* Limits of integral types. */
| | #ifndef INT8_MIN
| | #define INT8_MIN               (-128)
| | #endif
| | #ifndef INT16_MIN
| | #define INT16_MIN              (-32767-1)
| | #endif
| | #ifndef INT32_MIN
| | #define INT32_MIN              (-2147483647-1)
| | #endif
| | #ifndef INT8_MAX
| | #define INT8_MAX               (127)
| | #endif
| | #ifndef INT16_MAX
| | #define INT16_MAX              (32767)
| | #endif
| | #ifndef INT32_MAX
| | #define INT32_MAX              (2147483647)
| | #endif
| | #ifndef UINT8_MAX
| | #define UINT8_MAX              (255U)
| | #endif
| | #ifndef UINT16_MAX
| | #define UINT16_MAX             (65535U)
| | #endif
| | #ifndef UINT32_MAX
| | #define UINT32_MAX             (4294967295U)
| | #endif
| | 
| | #endif /* ! C99 */
| | 
| | #endif /* ! FLEXINT_H */
| | 
| | #ifdef __cplusplus
| | 
| | /* The "const" storage-class-modifier is valid. */
| | #define YY_USE_CONST
| | 
| | #else	/* ! __cplusplus */
| | 
| | /* C99 requires __STDC__ to be defined as 1. */
| | #if defined (__STDC__)
| | 
| | #define YY_USE_CONST
| | 
| | #endif	/* defined (__STDC__) */
| | #endif	/* ! __cplusplus */
| | 
| | #ifdef YY_USE_CONST
| | #define yyconst const
| | #else
| | #define yyconst
| | #endif
| | 
| | /* Returned upon end-of-file. */
| | #define YY_NULL 0
| | 
| | /* Promotes a possibly negative, possibly signed char to an unsigned
| |  * integer for use as an array index.  If the signed char is negative,
| |  * we want to instead treat it as an 8-bit unsigned char, hence the
| |  * double cast.
| |  */
| | #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| | 
| | /* Enter a start condition.  This macro really ought to take a parameter,
| |  * but we do it the disgusting crufty way forced on us by the ()-less
| |  * definition of BEGIN.
| |  */
| | #define BEGIN (yy_start) = 1 + 2 *
| | 
| | /* Translate the current start state into a value that can be later handed
| |  * to BEGIN to return to the state.  The YYSTATE alias is for lex
| |  * compatibility.
| |  */
| | #define YY_START (((yy_start) - 1) / 2)
| | #define YYSTATE YY_START
| | 
| | /* Action number for EOF rule of a given start state. */
| | #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| | 
| | /* Special action meaning "start processing a new file". */
| | #define YY_NEW_FILE yyrestart(yyin  )
| | 
| | #define YY_END_OF_BUFFER_CHAR 0
| | 
| | /* Size of default input buffer. */
| | #ifndef YY_BUF_SIZE
| | #ifdef __ia64__
| | /* On IA-64, the buffer size is 16k, not 8k.
| |  * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
| |  * Ditto for the __ia64__ case accordingly.
| |  */
| | #define YY_BUF_SIZE 32768
| | #else
| | #define YY_BUF_SIZE 16384
| | #endif /* __ia64__ */
| | #endif
| | 
| | /* The state buf must be large enough to hold one state per character in the main buffer.
| |  */
| | #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| | 
| | #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| | #define YY_TYPEDEF_YY_BUFFER_STATE
| | typedef struct yy_buffer_state *YY_BUFFER_STATE;
| | #endif
| | 
| | extern int yyleng;
| | 
| | extern FILE *yyin, *yyout;
| | 
| | #define EOB_ACT_CONTINUE_SCAN 0
| | #define EOB_ACT_END_OF_FILE 1
| | #define EOB_ACT_LAST_MATCH 2
| | 
| |     #define YY_LESS_LINENO(n)
| |     
| | /* Return all but the first "n" matched characters back to the input stream. */
| | #define yyless(n) \
| | 	do \
| | 		{ \
| | 		/* Undo effects of setting up yytext. */ \
| |         int yyless_macro_arg = (n); \
| |         YY_LESS_LINENO(yyless_macro_arg);\
| | 		*yy_cp = (yy_hold_char); \
| | 		YY_RESTORE_YY_MORE_OFFSET \
| | 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| | 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| | 		} \
| | 	while ( 0 )
| | 
| | #define unput(c) yyunput( c, (yytext_ptr)  )
| | 
| | #ifndef YY_TYPEDEF_YY_SIZE_T
| | #define YY_TYPEDEF_YY_SIZE_T
| | typedef size_t yy_size_t;
| | #endif
| | 
| | #ifndef YY_STRUCT_YY_BUFFER_STATE
| | #define YY_STRUCT_YY_BUFFER_STATE
| | struct yy_buffer_state
| | 	{
| | 	FILE *yy_input_file;
| | 
| | 	char *yy_ch_buf;		/* input buffer */
| | 	char *yy_buf_pos;		/* current position in input buffer */
| | 
| | 	/* Size of input buffer in bytes, not including room for EOB
| | 	 * characters.
| | 	 */
| | 	yy_size_t yy_buf_size;
| | 
| | 	/* Number of characters read into yy_ch_buf, not including EOB
| | 	 * characters.
| | 	 */
| | 	int yy_n_chars;
| | 
| | 	/* Whether we "own" the buffer - i.e., we know we created it,
| | 	 * and can realloc() it to grow it, and should free() it to
| | 	 * delete it.
| | 	 */
| | 	int yy_is_our_buffer;
| | 
| | 	/* Whether this is an "interactive" input source; if so, and
| | 	 * if we're using stdio for input, then we want to use getc()
| | 	 * instead of fread(), to make sure we stop fetching input after
| | 	 * each newline.
| | 	 */
| | 	int yy_is_interactive;
| | 
| | 	/* Whether we're considered to be at the beginning of a line.
| | 	 * If so, '^' rules will be active on the next match, otherwise
| | 	 * not.
| | 	 */
| | 	int yy_at_bol;
| | 
| |     int yy_bs_lineno; /**< The line count. */
| |     int yy_bs_column; /**< The column count. */
| |     
| | 	/* Whether to try to fill the input buffer when we reach the
| | 	 * end of it.
| | 	 */
| | 	int yy_fill_buffer;
| | 
| | 	int yy_buffer_status;
| | 
| | #define YY_BUFFER_NEW 0
| | #define YY_BUFFER_NORMAL 1
| | 	/* When an EOF's been seen but there's still some text to process
| | 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| | 	 * shouldn't try reading from the input source any more.  We might
| | 	 * still have a bunch of tokens to match, though, because of
| | 	 * possible backing-up.
| | 	 *
| | 	 * When we actually see the EOF, we change the status to "new"
| | 	 * (via yyrestart()), so that the user can continue scanning by
| | 	 * just pointing yyin at a new input file.
| | 	 */
| | #define YY_BUFFER_EOF_PENDING 2
| | 
| | 	};
| | #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| | 
| | /* Stack of input buffers. */
| | static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| | static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| | static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| | 
| | /* We provide macros for accessing buffer states in case in the
| |  * future we want to put the buffer states in a more general
| |  * "scanner state".
| |  *
| |  * Returns the top of the stack, or NULL.
| |  */
| | #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
| |                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
| |                           : NULL)
| | 
| | /* Same as previous macro, but useful when we know that the buffer stack is not
| |  * NULL or when we need an lvalue. For internal use only.
| |  */
| | #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| | 
| | /* yy_hold_char holds the character lost when yytext is formed. */
| | static char yy_hold_char;
| | static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| | int yyleng;
| | 
| | /* Points to current character in buffer. */
| | static char *yy_c_buf_p = (char *) 0;
| | static int yy_init = 0;		/* whether we need to initialize */
| | static int yy_start = 0;	/* start state number */
| | 
| | /* Flag which is used to allow yywrap()'s to do buffer switches
| |  * instead of setting up a fresh yyin.  A bit of a hack ...
| |  */
| | static int yy_did_buffer_switch_on_eof;
| | 
| | void yyrestart (FILE *input_file  );
| | void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| | YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| | void yy_delete_buffer (YY_BUFFER_STATE b  );
| | void yy_flush_buffer (YY_BUFFER_STATE b  );
| | void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| | void yypop_buffer_state (void );
| | 
| | static void yyensure_buffer_stack (void );
| | static void yy_load_buffer_state (void );
| | static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| | 
| | #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| | 
| | YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| | YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| | YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
| | 
| | void *yyalloc (yy_size_t  );
| | void *yyrealloc (void *,yy_size_t  );
| | void yyfree (void *  );
| | 
| | #define yy_new_buffer yy_create_buffer
| | 
| | #define yy_set_interactive(is_interactive) \
| | 	{ \
| | 	if ( ! YY_CURRENT_BUFFER ){ \
| |         yyensure_buffer_stack (); \
| | 		YY_CURRENT_BUFFER_LVALUE =    \
| |             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| | 	} \
| | 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| | 	}
| | 
| | #define yy_set_bol(at_bol) \
| | 	{ \
| | 	if ( ! YY_CURRENT_BUFFER ){\
| |         yyensure_buffer_stack (); \
| | 		YY_CURRENT_BUFFER_LVALUE =    \
| |             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| | 	} \
| | 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| | 	}
| | 
| | #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| | 
| | /* Begin user sect3 */
| | 
| | typedef unsigned char YY_CHAR;
| | 
| | FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| | 
| | typedef int yy_state_type;
| | 
| | extern int yylineno;
| | 
| | int yylineno = 1;
| | 
| | extern char *yytext;
| | #define yytext_ptr yytext
| | 
| | static yy_state_type yy_get_previous_state (void );
| | static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| | static int yy_get_next_buffer (void );
| | static void yy_fatal_error (yyconst char msg[]  );
| | 
| | /* Done after the current pattern has been matched and before the
| |  * corresponding action - sets up yytext.
| |  */
| | #define YY_DO_BEFORE_ACTION \
| | 	(yytext_ptr) = yy_bp; \
| | 	(yytext_ptr) -= (yy_more_len); \
| | 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| | 	(yy_hold_char) = *yy_cp; \
| | 	*yy_cp = '\0'; \
| | 	(yy_c_buf_p) = yy_cp;
| | 
| | #define YY_NUM_RULES 8
| | #define YY_END_OF_BUFFER 9
| | /* This struct is not used in this scanner,
| |    but its presence is necessary. */
| | struct yy_trans_info
| | 	{
| | 	flex_int32_t yy_verify;
| | 	flex_int32_t yy_nxt;
| | 	};
| | static yyconst flex_int16_t yy_acclist[23] =
| |     {   0,
| |         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
| |         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
| |         7,    8
| |     } ;
| | 
| | static yyconst flex_int16_t yy_accept[14] =
| |     {   0,
| |         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
| |        20,   23,   23
| |     } ;
| | 
| | static yyconst flex_int32_t yy_ec[256] =
| |     {   0,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| | 
| |         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| | 
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| |         1,    1,    1,    1,    1
| |     } ;
| | 
| | static yyconst flex_int32_t yy_meta[9] =
| |     {   0,
| |         1,    1,    1,    1,    1,    1,    1,    1
| |     } ;
| | 
| | static yyconst flex_int16_t yy_base[13] =
| |     {   0,
| |         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
| |        10,   10
| |     } ;
| | 
| | static yyconst flex_int16_t yy_def[13] =
| |     {   0,
| |        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
| |        12,    0
| |     } ;
| | 
| | static yyconst flex_int16_t yy_nxt[19] =
| |     {   0,
| |         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
| |        12,   12,   12,   12,   12,   12,   12,   12
| |     } ;
| | 
| | static yyconst flex_int16_t yy_chk[19] =
| |     {   0,
| |         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
| |        12,   12,   12,   12,   12,   12,   12,   12
| |     } ;
| | 
| | extern int yy_flex_debug;
| | int yy_flex_debug = 0;
| | 
| | static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| | static char *yy_full_match;
| | static int yy_lp;
| | #define REJECT \
| | { \
| | *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| | yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| | ++(yy_lp); \
| | goto find_rule; \
| | }
| | 
| | static int yy_more_flag = 0;
| | static int yy_more_len = 0;
| | #define yymore() ((yy_more_flag) = 1)
| | #define YY_MORE_ADJ (yy_more_len)
| | #define YY_RESTORE_YY_MORE_OFFSET
| | char *yytext;
| | #line 1 "conftest.l"
| | #line 477 "lex.yy.c"
| | 
| | #define INITIAL 0
| | 
| | #ifndef YY_NO_UNISTD_H
| | /* Special case for "unistd.h", since it is non-ANSI. We include it way
| |  * down here because we want the user's section 1 to have been scanned first.
| |  * The user has a chance to override it with an option.
| |  */
| | #include <unistd.h>
| | #endif
| | 
| | #ifndef YY_EXTRA_TYPE
| | #define YY_EXTRA_TYPE void *
| | #endif
| | 
| | static int yy_init_globals (void );
| | 
| | /* Accessor methods to globals.
| |    These are made visible to non-reentrant scanners for convenience. */
| | 
| | int yylex_destroy (void );
| | 
| | int yyget_debug (void );
| | 
| | void yyset_debug (int debug_flag  );
| | 
| | YY_EXTRA_TYPE yyget_extra (void );
| | 
| | void yyset_extra (YY_EXTRA_TYPE user_defined  );
| | 
| | FILE *yyget_in (void );
| | 
| | void yyset_in  (FILE * in_str  );
| | 
| | FILE *yyget_out (void );
| | 
| | void yyset_out  (FILE * out_str  );
| | 
| | int yyget_leng (void );
| | 
| | char *yyget_text (void );
| | 
| | int yyget_lineno (void );
| | 
| | void yyset_lineno (int line_number  );
| | 
| | /* Macros after this point can all be overridden by user definitions in
| |  * section 1.
| |  */
| | 
| | #ifndef YY_SKIP_YYWRAP
| | #ifdef __cplusplus
| | extern "C" int yywrap (void );
| | #else
| | extern int yywrap (void );
| | #endif
| | #endif
| | 
| |     static void yyunput (int c,char *buf_ptr  );
| |     
| | #ifndef yytext_ptr
| | static void yy_flex_strncpy (char *,yyconst char *,int );
| | #endif
| | 
| | #ifdef YY_NEED_STRLEN
| | static int yy_flex_strlen (yyconst char * );
| | #endif
| | 
| | #ifndef YY_NO_INPUT
| | 
| | #ifdef __cplusplus
| | static int yyinput (void );
| | #else
| | static int input (void );
| | #endif
| | 
| | #endif
| | 
| | /* Amount of stuff to slurp up with each read. */
| | #ifndef YY_READ_BUF_SIZE
| | #ifdef __ia64__
| | /* On IA-64, the buffer size is 16k, not 8k */
| | #define YY_READ_BUF_SIZE 16384
| | #else
| | #define YY_READ_BUF_SIZE 8192
| | #endif /* __ia64__ */
| | #endif
| | 
| | /* Copy whatever the last rule matched to the standard output. */
| | #ifndef ECHO
| | /* This used to be an fputs(), but since the string might contain NUL's,
| |  * we now use fwrite().
| |  */
| | #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| | #endif
| | 
| | /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
| |  * is returned in "result".
| |  */
| | #ifndef YY_INPUT
| | #define YY_INPUT(buf,result,max_size) \
| | 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| | 		{ \
| | 		int c = '*'; \
| | 		size_t n; \
| | 		for ( n = 0; n < max_size && \
| | 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| | 			buf[n] = (char) c; \
| | 		if ( c == '\n' ) \
| | 			buf[n++] = (char) c; \
| | 		if ( c == EOF && ferror( yyin ) ) \
| | 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| | 		result = n; \
| | 		} \
| | 	else \
| | 		{ \
| | 		errno=0; \
| | 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| | 			{ \
| | 			if( errno != EINTR) \
| | 				{ \
| | 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| | 				break; \
| | 				} \
| | 			errno=0; \
| | 			clearerr(yyin); \
| | 			} \
| | 		}\
| | \
| | 
| | #endif
| | 
| | /* No semi-colon after return; correct usage is to write "yyterminate();" -
| |  * we don't want an extra ';' after the "return" because that will cause
| |  * some compilers to complain about unreachable statements.
| |  */
| | #ifndef yyterminate
| | #define yyterminate() return YY_NULL
| | #endif
| | 
| | /* Number of entries by which start-condition stack grows. */
| | #ifndef YY_START_STACK_INCR
| | #define YY_START_STACK_INCR 25
| | #endif
| | 
| | /* Report a fatal error. */
| | #ifndef YY_FATAL_ERROR
| | #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| | #endif
| | 
| | /* end tables serialization structures and prototypes */
| | 
| | /* Default declaration of generated scanner - a define so the user can
| |  * easily add parameters.
| |  */
| | #ifndef YY_DECL
| | #define YY_DECL_IS_OURS 1
| | 
| | extern int yylex (void);
| | 
| | #define YY_DECL int yylex (void)
| | #endif /* !YY_DECL */
| | 
| | /* Code executed at the beginning of each rule, after yytext and yyleng
| |  * have been set up.
| |  */
| | #ifndef YY_USER_ACTION
| | #define YY_USER_ACTION
| | #endif
| | 
| | /* Code executed at the end of each rule. */
| | #ifndef YY_BREAK
| | #define YY_BREAK break;
| | #endif
| | 
| | #define YY_RULE_SETUP \
| | 	YY_USER_ACTION
| | 
| | /** The main scanner function which does all the work.
| |  */
| | YY_DECL
| | {
| | 	register yy_state_type yy_current_state;
| | 	register char *yy_cp, *yy_bp;
| | 	register int yy_act;
| |     
| | #line 1 "conftest.l"
| | 
| | #line 666 "lex.yy.c"
| | 
| | 	if ( !(yy_init) )
| | 		{
| | 		(yy_init) = 1;
| | 
| | #ifdef YY_USER_INIT
| | 		YY_USER_INIT;
| | #endif
| | 
| |         /* Create the reject buffer large enough to save one state per allowed character. */
| |         if ( ! (yy_state_buf) )
| |             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
| |             if ( ! (yy_state_buf) )
| |                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| | 
| | 		if ( ! (yy_start) )
| | 			(yy_start) = 1;	/* first start state */
| | 
| | 		if ( ! yyin )
| | 			yyin = stdin;
| | 
| | 		if ( ! yyout )
| | 			yyout = stdout;
| | 
| | 		if ( ! YY_CURRENT_BUFFER ) {
| | 			yyensure_buffer_stack ();
| | 			YY_CURRENT_BUFFER_LVALUE =
| | 				yy_create_buffer(yyin,YY_BUF_SIZE );
| | 		}
| | 
| | 		yy_load_buffer_state( );
| | 		}
| | 
| | 	while ( 1 )		/* loops until end-of-file is reached */
| | 		{
| | 		(yy_more_len) = 0;
| | 		if ( (yy_more_flag) )
| | 			{
| | 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| | 			(yy_more_flag) = 0;
| | 			}
| | 		yy_cp = (yy_c_buf_p);
| | 
| | 		/* Support of yytext. */
| | 		*yy_cp = (yy_hold_char);
| | 
| | 		/* yy_bp points to the position in yy_ch_buf of the start of
| | 		 * the current run.
| | 		 */
| | 		yy_bp = yy_cp;
| | 
| | 		yy_current_state = (yy_start);
| | 
| | 		(yy_state_ptr) = (yy_state_buf);
| | 		*(yy_state_ptr)++ = yy_current_state;
| | 
| | yy_match:
| | 		do
| | 			{
| | 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
| | 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| | 				{
| | 				yy_current_state = (int) yy_def[yy_current_state];
| | 				if ( yy_current_state >= 13 )
| | 					yy_c = yy_meta[(unsigned int) yy_c];
| | 				}
| | 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| | 			*(yy_state_ptr)++ = yy_current_state;
| | 			++yy_cp;
| | 			}
| | 		while ( yy_base[yy_current_state] != 10 );
| | 
| | yy_find_action:
| | 		yy_current_state = *--(yy_state_ptr);
| | 		(yy_lp) = yy_accept[yy_current_state];
| | find_rule: /* we branch to this label when backing up */
| | 		for ( ; ; ) /* until we find what rule we matched */
| | 			{
| | 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| | 				{
| | 				yy_act = yy_acclist[(yy_lp)];
| | 					{
| | 					(yy_full_match) = yy_cp;
| | 					break;
| | 					}
| | 				}
| | 			--yy_cp;
| | 			yy_current_state = *--(yy_state_ptr);
| | 			(yy_lp) = yy_accept[yy_current_state];
| | 			}
| | 
| | 		YY_DO_BEFORE_ACTION;
| | 
| | do_action:	/* This label is used only to access EOF actions. */
| | 
| | 		switch ( yy_act )
| | 	{ /* beginning of action switch */
| | case 1:
| | YY_RULE_SETUP
| | #line 2 "conftest.l"
| | { ECHO; }
| | 	YY_BREAK
| | case 2:
| | YY_RULE_SETUP
| | #line 3 "conftest.l"
| | { REJECT; }
| | 	YY_BREAK
| | case 3:
| | YY_RULE_SETUP
| | #line 4 "conftest.l"
| | { yymore (); }
| | 	YY_BREAK
| | case 4:
| | YY_RULE_SETUP
| | #line 5 "conftest.l"
| | { yyless (1); }
| | 	YY_BREAK
| | case 5:
| | YY_RULE_SETUP
| | #line 6 "conftest.l"
| | { yyless (input () != 0); }
| | 	YY_BREAK
| | case 6:
| | YY_RULE_SETUP
| | #line 7 "conftest.l"
| | { unput (yytext[0]); }
| | 	YY_BREAK
| | case 7:
| | YY_RULE_SETUP
| | #line 8 "conftest.l"
| | { BEGIN INITIAL; }
| | 	YY_BREAK
| | case 8:
| | YY_RULE_SETUP
| | #line 9 "conftest.l"
| | ECHO;
| | 	YY_BREAK
| | #line 804 "lex.yy.c"
| | 			case YY_STATE_EOF(INITIAL):
| | 				yyterminate();
| | 
| | 	case YY_END_OF_BUFFER:
| | 		{
| | 		/* Amount of text matched not including the EOB char. */
| | 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| | 
| | 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| | 		*yy_cp = (yy_hold_char);
| | 		YY_RESTORE_YY_MORE_OFFSET
| | 
| | 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| | 			{
| | 			/* We're scanning a new file or input source.  It's
| | 			 * possible that this happened because the user
| | 			 * just pointed yyin at a new source and called
| | 			 * yylex().  If so, then we have to assure
| | 			 * consistency between YY_CURRENT_BUFFER and our
| | 			 * globals.  Here is the right place to do so, because
| | 			 * this is the first action (other than possibly a
| | 			 * back-up) that will match for the new input source.
| | 			 */
| | 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| | 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| | 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| | 			}
| | 
| | 		/* Note that here we test for yy_c_buf_p "<=" to the position
| | 		 * of the first EOB in the buffer, since yy_c_buf_p will
| | 		 * already have been incremented past the NUL character
| | 		 * (since all states make transitions on EOB to the
| | 		 * end-of-buffer state).  Contrast this with the test
| | 		 * in input().
| | 		 */
| | 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| | 			{ /* This was really a NUL. */
| | 			yy_state_type yy_next_state;
| | 
| | 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| | 
| | 			yy_current_state = yy_get_previous_state(  );
| | 
| | 			/* Okay, we're now positioned to make the NUL
| | 			 * transition.  We couldn't have
| | 			 * yy_get_previous_state() go ahead and do it
| | 			 * for us because it doesn't know how to deal
| | 			 * with the possibility of jamming (and we don't
| | 			 * want to build jamming into it because then it
| | 			 * will run more slowly).
| | 			 */
| | 
| | 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| | 
| | 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| | 
| | 			if ( yy_next_state )
| | 				{
| | 				/* Consume the NUL. */
| | 				yy_cp = ++(yy_c_buf_p);
| | 				yy_current_state = yy_next_state;
| | 				goto yy_match;
| | 				}
| | 
| | 			else
| | 				{
| | 				yy_cp = (yy_c_buf_p);
| | 				goto yy_find_action;
| | 				}
| | 			}
| | 
| | 		else switch ( yy_get_next_buffer(  ) )
| | 			{
| | 			case EOB_ACT_END_OF_FILE:
| | 				{
| | 				(yy_did_buffer_switch_on_eof) = 0;
| | 
| | 				if ( yywrap( ) )
| | 					{
| | 					/* Note: because we've taken care in
| | 					 * yy_get_next_buffer() to have set up
| | 					 * yytext, we can now set up
| | 					 * yy_c_buf_p so that if some total
| | 					 * hoser (like flex itself) wants to
| | 					 * call the scanner after we return the
| | 					 * YY_NULL, it'll still work - another
| | 					 * YY_NULL will get returned.
| | 					 */
| | 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| | 
| | 					yy_act = YY_STATE_EOF(YY_START);
| | 					goto do_action;
| | 					}
| | 
| | 				else
| | 					{
| | 					if ( ! (yy_did_buffer_switch_on_eof) )
| | 						YY_NEW_FILE;
| | 					}
| | 				break;
| | 				}
| | 
| | 			case EOB_ACT_CONTINUE_SCAN:
| | 				(yy_c_buf_p) =
| | 					(yytext_ptr) + yy_amount_of_matched_text;
| | 
| | 				yy_current_state = yy_get_previous_state(  );
| | 
| | 				yy_cp = (yy_c_buf_p);
| | 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| | 				goto yy_match;
| | 
| | 			case EOB_ACT_LAST_MATCH:
| | 				(yy_c_buf_p) =
| | 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| | 
| | 				yy_current_state = yy_get_previous_state(  );
| | 
| | 				yy_cp = (yy_c_buf_p);
| | 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| | 				goto yy_find_action;
| | 			}
| | 		break;
| | 		}
| | 
| | 	default:
| | 		YY_FATAL_ERROR(
| | 			"fatal flex scanner internal error--no action found" );
| | 	} /* end of action switch */
| | 		} /* end of scanning one token */
| | } /* end of yylex */
| | 
| | /* yy_get_next_buffer - try to read in a new buffer
| |  *
| |  * Returns a code representing an action:
| |  *	EOB_ACT_LAST_MATCH -
| |  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
| |  *	EOB_ACT_END_OF_FILE - end of file
| |  */
| | static int yy_get_next_buffer (void)
| | {
| |     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| | 	register char *source = (yytext_ptr);
| | 	register int number_to_move, i;
| | 	int ret_val;
| | 
| | 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| | 		YY_FATAL_ERROR(
| | 		"fatal flex scanner internal error--end of buffer missed" );
| | 
| | 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| | 		{ /* Don't try to fill the buffer, so this is an EOF. */
| | 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| | 			{
| | 			/* We matched a single character, the EOB, so
| | 			 * treat this as a final EOF.
| | 			 */
| | 			return EOB_ACT_END_OF_FILE;
| | 			}
| | 
| | 		else
| | 			{
| | 			/* We matched some text prior to the EOB, first
| | 			 * process it.
| | 			 */
| | 			return EOB_ACT_LAST_MATCH;
| | 			}
| | 		}
| | 
| | 	/* Try to read more data. */
| | 
| | 	/* First move last chars to start of buffer. */
| | 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| | 
| | 	for ( i = 0; i < number_to_move; ++i )
| | 		*(dest++) = *(source++);
| | 
| | 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| | 		/* don't do the read, it's not guaranteed to return an EOF,
| | 		 * just force an EOF
| | 		 */
| | 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| | 
| | 	else
| | 		{
| | 			int num_to_read =
| | 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| | 
| | 		while ( num_to_read <= 0 )
| | 			{ /* Not enough room in the buffer - grow it. */
| | 
| | 			YY_FATAL_ERROR(
| | "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| | 
| | 			}
| | 
| | 		if ( num_to_read > YY_READ_BUF_SIZE )
| | 			num_to_read = YY_READ_BUF_SIZE;
| | 
| | 		/* Read in more data. */
| | 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| | 			(yy_n_chars), (size_t) num_to_read );
| | 
| | 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| | 		}
| | 
| | 	if ( (yy_n_chars) == 0 )
| | 		{
| | 		if ( number_to_move == YY_MORE_ADJ )
| | 			{
| | 			ret_val = EOB_ACT_END_OF_FILE;
| | 			yyrestart(yyin  );
| | 			}
| | 
| | 		else
| | 			{
| | 			ret_val = EOB_ACT_LAST_MATCH;
| | 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| | 				YY_BUFFER_EOF_PENDING;
| | 			}
| | 		}
| | 
| | 	else
| | 		ret_val = EOB_ACT_CONTINUE_SCAN;
| | 
| | 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| | 		/* Extend the array by 50%, plus the number we really need. */
| | 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| | 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| | 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| | 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| | 	}
| | 
| | 	(yy_n_chars) += number_to_move;
| | 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| | 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| | 
| | 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| | 
| | 	return ret_val;
| | }
| | 
| | /* yy_get_previous_state - get the state just before the EOB char was reached */
| | 
| |     static yy_state_type yy_get_previous_state (void)
| | {
| | 	register yy_state_type yy_current_state;
| | 	register char *yy_cp;
| |     
| | 	yy_current_state = (yy_start);
| | 
| | 	(yy_state_ptr) = (yy_state_buf);
| | 	*(yy_state_ptr)++ = yy_current_state;
| | 
| | 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| | 		{
| | 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| | 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| | 			{
| | 			yy_current_state = (int) yy_def[yy_current_state];
| | 			if ( yy_current_state >= 13 )
| | 				yy_c = yy_meta[(unsigned int) yy_c];
| | 			}
| | 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| | 		*(yy_state_ptr)++ = yy_current_state;
| | 		}
| | 
| | 	return yy_current_state;
| | }
| | 
| | /* yy_try_NUL_trans - try to make a transition on the NUL character
| |  *
| |  * synopsis
| |  *	next_state = yy_try_NUL_trans( current_state );
| |  */
| |     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| | {
| | 	register int yy_is_jam;
| |     
| | 	register YY_CHAR yy_c = 1;
| | 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| | 		{
| | 		yy_current_state = (int) yy_def[yy_current_state];
| | 		if ( yy_current_state >= 13 )
| | 			yy_c = yy_meta[(unsigned int) yy_c];
| | 		}
| | 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| | 	yy_is_jam = (yy_current_state == 12);
| | 	if ( ! yy_is_jam )
| | 		*(yy_state_ptr)++ = yy_current_state;
| | 
| | 	return yy_is_jam ? 0 : yy_current_state;
| | }
| | 
| |     static void yyunput (int c, register char * yy_bp )
| | {
| | 	register char *yy_cp;
| |     
| |     yy_cp = (yy_c_buf_p);
| | 
| | 	/* undo effects of setting up yytext */
| | 	*yy_cp = (yy_hold_char);
| | 
| | 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| | 		{ /* need to shift things up to make room */
| | 		/* +2 for EOB chars. */
| | 		register int number_to_move = (yy_n_chars) + 2;
| | 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| | 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| | 		register char *source =
| | 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| | 
| | 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| | 			*--dest = *--source;
| | 
| | 		yy_cp += (int) (dest - source);
| | 		yy_bp += (int) (dest - source);
| | 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| | 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| | 
| | 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| | 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| | 		}
| | 
| | 	*--yy_cp = (char) c;
| | 
| | 	(yytext_ptr) = yy_bp;
| | 	(yy_hold_char) = *yy_cp;
| | 	(yy_c_buf_p) = yy_cp;
| | }
| | 
| | #ifndef YY_NO_INPUT
| | #ifdef __cplusplus
| |     static int yyinput (void)
| | #else
| |     static int input  (void)
| | #endif
| | 
| | {
| | 	int c;
| |     
| | 	*(yy_c_buf_p) = (yy_hold_char);
| | 
| | 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| | 		{
| | 		/* yy_c_buf_p now points to the character we want to return.
| | 		 * If this occurs *before* the EOB characters, then it's a
| | 		 * valid NUL; if not, then we've hit the end of the buffer.
| | 		 */
| | 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| | 			/* This was really a NUL. */
| | 			*(yy_c_buf_p) = '\0';
| | 
| | 		else
| | 			{ /* need more input */
| | 			int offset = (yy_c_buf_p) - (yytext_ptr);
| | 			++(yy_c_buf_p);
| | 
| | 			switch ( yy_get_next_buffer(  ) )
| | 				{
| | 				case EOB_ACT_LAST_MATCH:
| | 					/* This happens because yy_g_n_b()
| | 					 * sees that we've accumulated a
| | 					 * token and flags that we need to
| | 					 * try matching the token before
| | 					 * proceeding.  But for input(),
| | 					 * there's no matching to consider.
| | 					 * So convert the EOB_ACT_LAST_MATCH
| | 					 * to EOB_ACT_END_OF_FILE.
| | 					 */
| | 
| | 					/* Reset buffer status. */
| | 					yyrestart(yyin );
| | 
| | 					/*FALLTHROUGH*/
| | 
| | 				case EOB_ACT_END_OF_FILE:
| | 					{
| | 					if ( yywrap( ) )
| | 						return EOF;
| | 
| | 					if ( ! (yy_did_buffer_switch_on_eof) )
| | 						YY_NEW_FILE;
| | #ifdef __cplusplus
| | 					return yyinput();
| | #else
| | 					return input();
| | #endif
| | 					}
| | 
| | 				case EOB_ACT_CONTINUE_SCAN:
| | 					(yy_c_buf_p) = (yytext_ptr) + offset;
| | 					break;
| | 				}
| | 			}
| | 		}
| | 
| | 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| | 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| | 	(yy_hold_char) = *++(yy_c_buf_p);
| | 
| | 	return c;
| | }
| | #endif	/* ifndef YY_NO_INPUT */
| | 
| | /** Immediately switch to a different input stream.
| |  * @param input_file A readable stream.
| |  * 
| |  * @note This function does not reset the start condition to @c INITIAL .
| |  */
| |     void yyrestart  (FILE * input_file )
| | {
| |     
| | 	if ( ! YY_CURRENT_BUFFER ){
| |         yyensure_buffer_stack ();
| | 		YY_CURRENT_BUFFER_LVALUE =
| |             yy_create_buffer(yyin,YY_BUF_SIZE );
| | 	}
| | 
| | 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| | 	yy_load_buffer_state( );
| | }
| | 
| | /** Switch to a different input buffer.
| |  * @param new_buffer The new input buffer.
| |  * 
| |  */
| |     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| | {
| |     
| | 	/* TODO. We should be able to replace this entire function body
| | 	 * with
| | 	 *		yypop_buffer_state();
| | 	 *		yypush_buffer_state(new_buffer);
| |      */
| | 	yyensure_buffer_stack ();
| | 	if ( YY_CURRENT_BUFFER == new_buffer )
| | 		return;
| | 
| | 	if ( YY_CURRENT_BUFFER )
| | 		{
| | 		/* Flush out information for old buffer. */
| | 		*(yy_c_buf_p) = (yy_hold_char);
| | 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| | 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| | 		}
| | 
| | 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| | 	yy_load_buffer_state( );
| | 
| | 	/* We don't actually know whether we did this switch during
| | 	 * EOF (yywrap()) processing, but the only time this flag
| | 	 * is looked at is after yywrap() is called, so it's safe
| | 	 * to go ahead and always set it.
| | 	 */
| | 	(yy_did_buffer_switch_on_eof) = 1;
| | }
| | 
| | static void yy_load_buffer_state  (void)
| | {
| |     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| | 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| | 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| | 	(yy_hold_char) = *(yy_c_buf_p);
| | }
| | 
| | /** Allocate and initialize an input buffer state.
| |  * @param file A readable stream.
| |  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
| |  * 
| |  * @return the allocated buffer state.
| |  */
| |     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| | {
| | 	YY_BUFFER_STATE b;
| |     
| | 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| | 	if ( ! b )
| | 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| | 
| | 	b->yy_buf_size = size;
| | 
| | 	/* yy_ch_buf has to be 2 characters longer than the size given because
| | 	 * we need to put in 2 end-of-buffer characters.
| | 	 */
| | 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| | 	if ( ! b->yy_ch_buf )
| | 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| | 
| | 	b->yy_is_our_buffer = 1;
| | 
| | 	yy_init_buffer(b,file );
| | 
| | 	return b;
| | }
| | 
| | /** Destroy the buffer.
| |  * @param b a buffer created with yy_create_buffer()
| |  * 
| |  */
| |     void yy_delete_buffer (YY_BUFFER_STATE  b )
| | {
| |     
| | 	if ( ! b )
| | 		return;
| | 
| | 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| | 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| | 
| | 	if ( b->yy_is_our_buffer )
| | 		yyfree((void *) b->yy_ch_buf  );
| | 
| | 	yyfree((void *) b  );
| | }
| | 
| | #ifndef __cplusplus
| | extern int isatty (int );
| | #endif /* __cplusplus */
| |     
| | /* Initializes or reinitializes a buffer.
| |  * This function is sometimes called more than once on the same buffer,
| |  * such as during a yyrestart() or at EOF.
| |  */
| |     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| | 
| | {
| | 	int oerrno = errno;
| |     
| | 	yy_flush_buffer(b );
| | 
| | 	b->yy_input_file = file;
| | 	b->yy_fill_buffer = 1;
| | 
| |     /* If b is the current buffer, then yy_init_buffer was _probably_
| |      * called from yyrestart() or through yy_get_next_buffer.
| |      * In that case, we don't want to reset the lineno or column.
| |      */
| |     if (b != YY_CURRENT_BUFFER){
| |         b->yy_bs_lineno = 1;
| |         b->yy_bs_column = 0;
| |     }
| | 
| |         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
| |     
| | 	errno = oerrno;
| | }
| | 
| | /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
| |  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
| |  * 
| |  */
| |     void yy_flush_buffer (YY_BUFFER_STATE  b )
| | {
| |     	if ( ! b )
| | 		return;
| | 
| | 	b->yy_n_chars = 0;
| | 
| | 	/* We always need two end-of-buffer characters.  The first causes
| | 	 * a transition to the end-of-buffer state.  The second causes
| | 	 * a jam in that state.
| | 	 */
| | 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| | 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| | 
| | 	b->yy_buf_pos = &b->yy_ch_buf[0];
| | 
| | 	b->yy_at_bol = 1;
| | 	b->yy_buffer_status = YY_BUFFER_NEW;
| | 
| | 	if ( b == YY_CURRENT_BUFFER )
| | 		yy_load_buffer_state( );
| | }
| | 
| | /** Pushes the new state onto the stack. The new state becomes
| |  *  the current state. This function will allocate the stack
| |  *  if necessary.
| |  *  @param new_buffer The new state.
| |  *  
| |  */
| | void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| | {
| |     	if (new_buffer == NULL)
| | 		return;
| | 
| | 	yyensure_buffer_stack();
| | 
| | 	/* This block is copied from yy_switch_to_buffer. */
| | 	if ( YY_CURRENT_BUFFER )
| | 		{
| | 		/* Flush out information for old buffer. */
| | 		*(yy_c_buf_p) = (yy_hold_char);
| | 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| | 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| | 		}
| | 
| | 	/* Only push if top exists. Otherwise, replace top. */
| | 	if (YY_CURRENT_BUFFER)
| | 		(yy_buffer_stack_top)++;
| | 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| | 
| | 	/* copied from yy_switch_to_buffer. */
| | 	yy_load_buffer_state( );
| | 	(yy_did_buffer_switch_on_eof) = 1;
| | }
| | 
| | /** Removes and deletes the top of the stack, if present.
| |  *  The next element becomes the new top.
| |  *  
| |  */
| | void yypop_buffer_state (void)
| | {
| |     	if (!YY_CURRENT_BUFFER)
| | 		return;
| | 
| | 	yy_delete_buffer(YY_CURRENT_BUFFER );
| | 	YY_CURRENT_BUFFER_LVALUE = NULL;
| | 	if ((yy_buffer_stack_top) > 0)
| | 		--(yy_buffer_stack_top);
| | 
| | 	if (YY_CURRENT_BUFFER) {
| | 		yy_load_buffer_state( );
| | 		(yy_did_buffer_switch_on_eof) = 1;
| | 	}
| | }
| | 
| | /* Allocates the stack if it does not exist.
| |  *  Guarantees space for at least one push.
| |  */
| | static void yyensure_buffer_stack (void)
| | {
| | 	int num_to_alloc;
| |     
| | 	if (!(yy_buffer_stack)) {
| | 
| | 		/* First allocation is just for 2 elements, since we don't know if this
| | 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| | 		 * immediate realloc on the next call.
| |          */
| | 		num_to_alloc = 1;
| | 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| | 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| | 								);
| | 		if ( ! (yy_buffer_stack) )
| | 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| | 								  
| | 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| | 				
| | 		(yy_buffer_stack_max) = num_to_alloc;
| | 		(yy_buffer_stack_top) = 0;
| | 		return;
| | 	}
| | 
| | 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| | 
| | 		/* Increase the buffer to prepare for a possible push. */
| | 		int grow_size = 8 /* arbitrary grow size */;
| | 
| | 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| | 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| | 								((yy_buffer_stack),
| | 								num_to_alloc * sizeof(struct yy_buffer_state*)
| | 								);
| | 		if ( ! (yy_buffer_stack) )
| | 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| | 
| | 		/* zero only the new slots.*/
| | 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| | 		(yy_buffer_stack_max) = num_to_alloc;
| | 	}
| | }
| | 
| | /** Setup the input buffer state to scan directly from a user-specified character buffer.
| |  * @param base the character buffer
| |  * @param size the size in bytes of the character buffer
| |  * 
| |  * @return the newly allocated buffer state object. 
| |  */
| | YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| | {
| | 	YY_BUFFER_STATE b;
| |     
| | 	if ( size < 2 ||
| | 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| | 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| | 		/* They forgot to leave room for the EOB's. */
| | 		return 0;
| | 
| | 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| | 	if ( ! b )
| | 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| | 
| | 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| | 	b->yy_buf_pos = b->yy_ch_buf = base;
| | 	b->yy_is_our_buffer = 0;
| | 	b->yy_input_file = 0;
| | 	b->yy_n_chars = b->yy_buf_size;
| | 	b->yy_is_interactive = 0;
| | 	b->yy_at_bol = 1;
| | 	b->yy_fill_buffer = 0;
| | 	b->yy_buffer_status = YY_BUFFER_NEW;
| | 
| | 	yy_switch_to_buffer(b  );
| | 
| | 	return b;
| | }
| | 
| | /** Setup the input buffer state to scan a string. The next call to yylex() will
| |  * scan from a @e copy of @a str.
| |  * @param yystr a NUL-terminated string to scan
| |  * 
| |  * @return the newly allocated buffer state object.
| |  * @note If you want to scan bytes that may contain NUL values, then use
| |  *       yy_scan_bytes() instead.
| |  */
| | YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| | {
| |     
| | 	return yy_scan_bytes(yystr,strlen(yystr) );
| | }
| | 
| | /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
| |  * scan from a @e copy of @a bytes.
| |  * @param yybytes the byte buffer to scan
| |  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
| |  * 
| |  * @return the newly allocated buffer state object.
| |  */
| | YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
| | {
| | 	YY_BUFFER_STATE b;
| | 	char *buf;
| | 	yy_size_t n;
| | 	int i;
| |     
| | 	/* Get memory for full buffer, including space for trailing EOB's. */
| | 	n = _yybytes_len + 2;
| | 	buf = (char *) yyalloc(n  );
| | 	if ( ! buf )
| | 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| | 
| | 	for ( i = 0; i < _yybytes_len; ++i )
| | 		buf[i] = yybytes[i];
| | 
| | 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| | 
| | 	b = yy_scan_buffer(buf,n );
| | 	if ( ! b )
| | 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| | 
| | 	/* It's okay to grow etc. this buffer, and we should throw it
| | 	 * away when we're done.
| | 	 */
| | 	b->yy_is_our_buffer = 1;
| | 
| | 	return b;
| | }
| | 
| | #ifndef YY_EXIT_FAILURE
| | #define YY_EXIT_FAILURE 2
| | #endif
| | 
| | static void yy_fatal_error (yyconst char* msg )
| | {
| |     	(void) fprintf( stderr, "%s\n", msg );
| | 	exit( YY_EXIT_FAILURE );
| | }
| | 
| | /* Redefine yyless() so it works in section 3 code. */
| | 
| | #undef yyless
| | #define yyless(n) \
| | 	do \
| | 		{ \
| | 		/* Undo effects of setting up yytext. */ \
| |         int yyless_macro_arg = (n); \
| |         YY_LESS_LINENO(yyless_macro_arg);\
| | 		yytext[yyleng] = (yy_hold_char); \
| | 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| | 		(yy_hold_char) = *(yy_c_buf_p); \
| | 		*(yy_c_buf_p) = '\0'; \
| | 		yyleng = yyless_macro_arg; \
| | 		} \
| | 	while ( 0 )
| | 
| | /* Accessor  methods (get/set functions) to struct members. */
| | 
| | /** Get the current line number.
| |  * 
| |  */
| | int yyget_lineno  (void)
| | {
| |         
| |     return yylineno;
| | }
| | 
| | /** Get the input stream.
| |  * 
| |  */
| | FILE *yyget_in  (void)
| | {
| |         return yyin;
| | }
| | 
| | /** Get the output stream.
| |  * 
| |  */
| | FILE *yyget_out  (void)
| | {
| |         return yyout;
| | }
| | 
| | /** Get the length of the current token.
| |  * 
| |  */
| | int yyget_leng  (void)
| | {
| |         return yyleng;
| | }
| | 
| | /** Get the current token.
| |  * 
| |  */
| | 
| | char *yyget_text  (void)
| | {
| |         return yytext;
| | }
| | 
| | /** Set the current line number.
| |  * @param line_number
| |  * 
| |  */
| | void yyset_lineno (int  line_number )
| | {
| |     
| |     yylineno = line_number;
| | }
| | 
| | /** Set the input stream. This does not discard the current
| |  * input buffer.
| |  * @param in_str A readable stream.
| |  * 
| |  * @see yy_switch_to_buffer
| |  */
| | void yyset_in (FILE *  in_str )
| | {
| |         yyin = in_str ;
| | }
| | 
| | void yyset_out (FILE *  out_str )
| | {
| |         yyout = out_str ;
| | }
| | 
| | int yyget_debug  (void)
| | {
| |         return yy_flex_debug;
| | }
| | 
| | void yyset_debug (int  bdebug )
| | {
| |         yy_flex_debug = bdebug ;
| | }
| | 
| | static int yy_init_globals (void)
| | {
| |         /* Initialization is the same as for the non-reentrant scanner.
| |      * This function is called from yylex_destroy(), so don't allocate here.
| |      */
| | 
| |     (yy_buffer_stack) = 0;
| |     (yy_buffer_stack_top) = 0;
| |     (yy_buffer_stack_max) = 0;
| |     (yy_c_buf_p) = (char *) 0;
| |     (yy_init) = 0;
| |     (yy_start) = 0;
| | 
| |     (yy_state_buf) = 0;
| |     (yy_state_ptr) = 0;
| |     (yy_full_match) = 0;
| |     (yy_lp) = 0;
| | 
| | /* Defined in main.c */
| | #ifdef YY_STDINIT
| |     yyin = stdin;
| |     yyout = stdout;
| | #else
| |     yyin = (FILE *) 0;
| |     yyout = (FILE *) 0;
| | #endif
| | 
| |     /* For future reference: Set errno on error, since we are called by
| |      * yylex_init()
| |      */
| |     return 0;
| | }
| | 
| | /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| | int yylex_destroy  (void)
| | {
| |     
| |     /* Pop the buffer stack, destroying each element. */
| | 	while(YY_CURRENT_BUFFER){
| | 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| | 		YY_CURRENT_BUFFER_LVALUE = NULL;
| | 		yypop_buffer_state();
| | 	}
| | 
| | 	/* Destroy the stack itself. */
| | 	yyfree((yy_buffer_stack) );
| | 	(yy_buffer_stack) = NULL;
| | 
| |     yyfree ( (yy_state_buf) );
| |     (yy_state_buf)  = NULL;
| | 
| |     /* Reset the globals. This is important in a non-reentrant scanner so the next time
| |      * yylex() is called, initialization will occur. */
| |     yy_init_globals( );
| | 
| |     return 0;
| | }
| | 
| | /*
| |  * Internal utility routines.
| |  */
| | 
| | #ifndef yytext_ptr
| | static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| | {
| | 	register int i;
| | 	for ( i = 0; i < n; ++i )
| | 		s1[i] = s2[i];
| | }
| | #endif
| | 
| | #ifdef YY_NEED_STRLEN
| | static int yy_flex_strlen (yyconst char * s )
| | {
| | 	register int n;
| | 	for ( n = 0; s[n]; ++n )
| | 		;
| | 
| | 	return n;
| | }
| | #endif
| | 
| | void *yyalloc (yy_size_t  size )
| | {
| | 	return (void *) malloc( size );
| | }
| | 
| | void *yyrealloc  (void * ptr, yy_size_t  size )
| | {
| | 	/* The cast to (char *) in the following accommodates both
| | 	 * implementations that use char* generic pointers, and those
| | 	 * that use void* generic pointers.  It works with the latter
| | 	 * because both ANSI C and C++ allow castless assignment from
| | 	 * any pointer type to void*, and deal with argument conversions
| | 	 * as though doing an assignment.
| | 	 */
| | 	return (void *) realloc( (char *) ptr, size );
| | }
| | 
| | void yyfree (void * ptr )
| | {
| | 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| | }
| | 
| | #define YYTABLES_NAME "yytables"
| | 
| | #line 9 "conftest.l"
| | 
| | 
| | #ifdef YYTEXT_POINTER
| | extern char *yytext;
| | #endif
| | int
| | main (void)
| | {
| |   return ! yylex () + ! yywrap ();
| | }
| configure:4333: gcc -o conftest -g -O2   conftest.c -lfl  >&5
| configure:4333: $? = 0
| configure:4343: result: -lfl
| configure:4349: checking whether yytext is a pointer
| configure:4365: gcc -o conftest -g -O2   conftest.c -lfl  >&5
| configure:4365: $? = 0
| configure:4373: result: yes
| configure:4387: checking for bison
| configure:4403: found /usr/bin/bison
| configure:4414: result: bison -y
| configure:4432: checking build system type
| configure:4446: result: x86_64-unknown-linux-gnu
| configure:4467: checking whether to enable assertions
| configure:4485: result: yes
| configure:4508: checking for a sed that does not truncate output
| configure:4572: result: /bin/sed
| configure:4577: checking for grep that handles long lines and -e
| configure:4635: result: /bin/grep
| configure:4644: checking for gawk
| configure:4671: result: gawk
| configure:4765: checking for ranlib
| configure:4781: found /usr/bin/ranlib
| configure:4792: result: ranlib
| configure:4836: checking for libpnapi_is_present in -lpnapi
| configure:4861: g++ -o conftest -g -O2   conftest.cpp -lpnapi   >&5
| configure:4861: $? = 0
| configure:4870: result: yes
| configure:4881: checking whether to use installed Petri Net API
| configure:4885: result: yes
| configure:4985: checking for mktemp
| configure:4985: g++ -o conftest -g -O2   conftest.cpp -lpnapi  >&5
| /tmp/ccLjMWRH.o: In function `main':
| /home/jeed/workspace/cosme/conftest.cpp:51: warning: the use of `mktemp' is dangerous, better use `mkstemp' or `mkdtemp'
| configure:4985: $? = 0
| configure:4985: result: yes
| configure:4985: checking for vfprintf
| configure:4985: g++ -o conftest -g -O2   conftest.cpp -lpnapi  >&5
| configure:4985: $? = 0
| configure:4985: result: yes
| configure:5003: checking for valgrind
| configure:5021: found /usr/bin/valgrind
| configure:5034: result: /usr/bin/valgrind
| configure:5044: checking for lola-statespace
| configure:5062: found /usr/local/bin/lola-statespace
| configure:5074: result: /usr/local/bin/lola-statespace
| configure:5087: checking for popen
| configure:5087: g++ -o conftest -g -O2   conftest.cpp -lpnapi  >&5
| configure:5087: $? = 0
| configure:5087: result: yes
| configure:5087: checking for pclose
| configure:5087: g++ -o conftest -g -O2   conftest.cpp -lpnapi  >&5
| configure:5087: $? = 0
| configure:5087: result: yes
| configure:5106: checking how to run the C++ preprocessor
| configure:5133: g++ -E  conftest.cpp
| configure:5133: $? = 0
| configure:5147: g++ -E  conftest.cpp
| conftest.cpp:21:28: error: ac_nonexistent.h: No such file or directory
| configure:5147: $? = 1
| configure: failed program was:
| | /* confdefs.h */
| | #define PACKAGE_NAME "Cosme"
| | #define PACKAGE_TARNAME "cosme"
| | #define PACKAGE_VERSION "0.7"
| | #define PACKAGE_STRING "Cosme 0.7"
| | #define PACKAGE_BUGREPORT "cosme@service-technology.org"
| | #define PACKAGE_URL "http://service-technology.org/cosme"
| | #define PACKAGE "cosme"
| | #define VERSION "0.7"
| | #define YYTEXT_POINTER 1
| | #define VERSION_SVN "5755"
| | #define CONFIG_BUILDSYSTEM "x86_64-unknown-linux-gnu"
| | #define TOOL_AWK "\"gawk\""
| | #define TOOL_GREP "\"/bin/grep\""
| | #define HAVE_LIBPNAPI 1
| | #define HAVE_MKTEMP 1
| | #define HAVE_VFPRINTF 1
| | #define HAVE_POPEN 1
| | #define HAVE_PCLOSE 1
| | /* end confdefs.h.  */
| | #include <ac_nonexistent.h>
| configure:5172: result: g++ -E
| configure:5192: g++ -E  conftest.cpp
| configure:5192: $? = 0
| configure:5206: g++ -E  conftest.cpp
| conftest.cpp:21:28: error: ac_nonexistent.h: No such file or directory
| configure:5206: $? = 1
| configure: failed program was:
| | /* confdefs.h */
| | #define PACKAGE_NAME "Cosme"
| | #define PACKAGE_TARNAME "cosme"
| | #define PACKAGE_VERSION "0.7"
| | #define PACKAGE_STRING "Cosme 0.7"
| | #define PACKAGE_BUGREPORT "cosme@service-technology.org"
| | #define PACKAGE_URL "http://service-technology.org/cosme"
| | #define PACKAGE "cosme"
| | #define VERSION "0.7"
| | #define YYTEXT_POINTER 1
| | #define VERSION_SVN "5755"
| | #define CONFIG_BUILDSYSTEM "x86_64-unknown-linux-gnu"
| | #define TOOL_AWK "\"gawk\""
| | #define TOOL_GREP "\"/bin/grep\""
| | #define HAVE_LIBPNAPI 1
| | #define HAVE_MKTEMP 1
| | #define HAVE_VFPRINTF 1
| | #define HAVE_POPEN 1
| | #define HAVE_PCLOSE 1
| | /* end confdefs.h.  */
| | #include <ac_nonexistent.h>
| configure:5235: checking for egrep
| configure:5297: result: /bin/grep -E
| configure:5302: checking for ANSI C header files
| configure:5322: g++ -c -g -O2  conftest.cpp >&5
| configure:5322: $? = 0
| configure:5395: g++ -o conftest -g -O2   conftest.cpp -lpnapi  >&5
| configure:5395: $? = 0
| configure:5395: ./conftest
| configure:5395: $? = 0
| configure:5406: result: yes
| configure:5419: checking for sys/types.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5419: checking for sys/stat.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5419: checking for stdlib.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5419: checking for string.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5419: checking for memory.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5419: checking for strings.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5419: checking for inttypes.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5419: checking for stdint.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5419: checking for unistd.h
| configure:5419: g++ -c -g -O2  conftest.cpp >&5
| configure:5419: $? = 0
| configure:5419: result: yes
| configure:5432: checking for uint8_t
| configure:5432: g++ -c -g -O2  conftest.cpp >&5
| configure:5432: $? = 0
| configure:5432: result: yes
| configure:5446: checking for uint16_t
| configure:5446: g++ -c -g -O2  conftest.cpp >&5
| configure:5446: $? = 0
| configure:5446: result: yes
| configure:5458: checking for uint32_t
| configure:5458: g++ -c -g -O2  conftest.cpp >&5
| configure:5458: $? = 0
| configure:5458: result: yes
| configure:5612: creating ./config.status
| 
| ## ---------------------- ##
| ## Running config.status. ##
| ## ---------------------- ##
| 
| This file was extended by Cosme config.status 0.7, which was
| generated by GNU Autoconf 2.65.  Invocation command line was
| 
|   CONFIG_FILES    = 
|   CONFIG_HEADERS  = 
|   CONFIG_LINKS    = 
|   CONFIG_COMMANDS = 
|   $ ./config.status 
| 
| on SomTam
| 
| config.status:896: creating Makefile
| config.status:896: creating libs/pnapi/Makefile
| config.status:896: creating src/Makefile
| config.status:896: creating doc/Doxyfile
| config.status:896: creating tests/Makefile
| config.status:896: creating tests/package.m4
| config.status:896: creating tests/cover.sh
| config.status:896: creating src/config.h
| config.status:1116: executing depfiles commands
| config.status:1116: executing tests/atconfig commands
| 
| ## ---------------- ##
| ## Cache variables. ##
| ## ---------------- ##
| 
| ac_cv_build=x86_64-unknown-linux-gnu
| ac_cv_c_compiler_gnu=yes
| ac_cv_c_uint16_t=yes
| ac_cv_c_uint32_t=yes
| ac_cv_c_uint8_t=yes
| ac_cv_cxx_compiler_gnu=yes
| ac_cv_env_CCC_set=
| ac_cv_env_CCC_value=
| ac_cv_env_CC_set=
| ac_cv_env_CC_value=
| ac_cv_env_CFLAGS_set=
| ac_cv_env_CFLAGS_value=
| ac_cv_env_CPPFLAGS_set=
| ac_cv_env_CPPFLAGS_value=
| ac_cv_env_CXXCPP_set=
| ac_cv_env_CXXCPP_value=
| ac_cv_env_CXXFLAGS_set=
| ac_cv_env_CXXFLAGS_value=
| ac_cv_env_CXX_set=
| ac_cv_env_CXX_value=
| ac_cv_env_LDFLAGS_set=
| ac_cv_env_LDFLAGS_value=
| ac_cv_env_LIBS_set=
| ac_cv_env_LIBS_value=
| ac_cv_env_YACC_set=
| ac_cv_env_YACC_value=
| ac_cv_env_YFLAGS_set=
| ac_cv_env_YFLAGS_value=
| ac_cv_env_build_alias_set=
| ac_cv_env_build_alias_value=
| ac_cv_env_host_alias_set=
| ac_cv_env_host_alias_value=
| ac_cv_env_target_alias_set=
| ac_cv_env_target_alias_value=
| ac_cv_func_mktemp=yes
| ac_cv_func_pclose=yes
| ac_cv_func_popen=yes
| ac_cv_func_vfprintf=yes
| ac_cv_header_inttypes_h=yes
| ac_cv_header_memory_h=yes
| ac_cv_header_stdc=yes
| ac_cv_header_stdint_h=yes
| ac_cv_header_stdlib_h=yes
| ac_cv_header_string_h=yes
| ac_cv_header_strings_h=yes
| ac_cv_header_sys_stat_h=yes
| ac_cv_header_sys_types_h=yes
| ac_cv_header_unistd_h=yes
| ac_cv_lib_lex=-lfl
| ac_cv_lib_pnapi_libpnapi_is_present=yes
| ac_cv_objext=o
| ac_cv_path_EGREP='/bin/grep -E'
| ac_cv_path_GREP=/bin/grep
| ac_cv_path_LOLA=/usr/local/bin/lola-statespace
| ac_cv_path_SED=/bin/sed
| ac_cv_path_VALGRIND=/usr/bin/valgrind
| ac_cv_path_install='/usr/bin/install -c'
| ac_cv_path_mkdir=/bin/mkdir
| ac_cv_prog_AWK=gawk
| ac_cv_prog_CXXCPP='g++ -E'
| ac_cv_prog_LEX=flex
| ac_cv_prog_YACC='bison -y'
| ac_cv_prog_ac_ct_CC=gcc
| ac_cv_prog_ac_ct_CXX=g++
| ac_cv_prog_ac_ct_RANLIB=ranlib
| ac_cv_prog_cc_c89=
| ac_cv_prog_cc_g=yes
| ac_cv_prog_cc_gcc_c_o=yes
| ac_cv_prog_cxx_g=yes
| ac_cv_prog_lex_root=lex.yy
| ac_cv_prog_lex_yytext_pointer=yes
| ac_cv_prog_make_make_set=yes
| am_cv_CC_dependencies_compiler_type=gcc3
| am_cv_CXX_dependencies_compiler_type=gcc3
| 
| ## ----------------- ##
| ## Output variables. ##
| ## ----------------- ##
| 
| ACLOCAL='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run aclocal-1.11'
| AMDEPBACKSLASH='\'
| AMDEP_FALSE='#'
| AMDEP_TRUE=''
| AMTAR='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run tar'
| AM_BACKSLASH='\'
| AM_DEFAULT_VERBOSITY='0'
| AUTOCONF='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run autoconf'
| AUTOHEADER='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run autoheader'
| AUTOM4TE='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run autom4te'
| AUTOMAKE='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run automake-1.11'
| AWK='gawk'
| CC='gcc'
| CCDEPMODE='depmode=gcc3'
| CFLAGS='-g -O2'
| COMPILE_PNAPI_FALSE=''
| COMPILE_PNAPI_TRUE='#'
| CPPFLAGS=''
| CXX='g++'
| CXXCPP='g++ -E'
| CXXDEPMODE='depmode=gcc3'
| CXXFLAGS='-g -O2'
| CYGPATH_W='echo'
| DEFS='-DHAVE_CONFIG_H'
| DEPDIR='.deps'
| ECHO_C=''
| ECHO_N='-n'
| ECHO_T=''
| EGREP='/bin/grep -E'
| EXEEXT=''
| GENGETOPT='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run gengetopt'
| GREP='/bin/grep'
| HELP2MAN='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run help2man'
| INSTALL_DATA='${INSTALL} -m 644'
| INSTALL_PROGRAM='${INSTALL}'
| INSTALL_SCRIPT='${INSTALL}'
| INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
| LDFLAGS=''
| LEX='flex'
| LEXLIB='-lfl'
| LEX_OUTPUT_ROOT='lex.yy'
| LIBOBJS=''
| LIBS='-lpnapi '
| LOLA='/usr/local/bin/lola-statespace'
| LTLIBOBJS=''
| MAKEINFO='${SHELL} /home/jeed/workspace/cosme/build-aux/missing --run makeinfo'
| MKDIR_P='/bin/mkdir -p'
| OBJEXT='o'
| PACKAGE='cosme'
| PACKAGE_BUGREPORT='cosme@service-technology.org'
| PACKAGE_NAME='Cosme'
| PACKAGE_STRING='Cosme 0.7'
| PACKAGE_TARNAME='cosme'
| PACKAGE_URL='http://service-technology.org/cosme'
| PACKAGE_VERSION='0.7'
| PATH_SEPARATOR=':'
| RANLIB='ranlib'
| SED='/bin/sed'
| SET_MAKE=''
| SHELL='/bin/bash'
| STRIP=''
| VALGRIND='/usr/bin/valgrind'
| VERSION='0.7'
| VERSION_SVN='5755'
| YACC='bison -y'
| YFLAGS=''
| ac_ct_CC='gcc'
| ac_ct_CXX='g++'
| am__EXEEXT_FALSE=''
| am__EXEEXT_TRUE='#'
| am__fastdepCC_FALSE='#'
| am__fastdepCC_TRUE=''
| am__fastdepCXX_FALSE='#'
| am__fastdepCXX_TRUE=''
| am__include='include'
| am__isrc=''
| am__leading_dot='.'
| am__quote=''
| am__tar='${AMTAR} chof - "$$tardir"'
| am__untar='${AMTAR} xf -'
| bindir='${exec_prefix}/bin'
| build='x86_64-unknown-linux-gnu'
| build_alias=''
| build_cpu='x86_64'
| build_os='linux-gnu'
| build_vendor='unknown'
| datadir='${datarootdir}'
| datarootdir='${prefix}/share'
| docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
| dvidir='${docdir}'
| exec_prefix='${prefix}'
| host_alias=''
| htmldir='${docdir}'
| includedir='${prefix}/include'
| infodir='${datarootdir}/info'
| install_sh='${SHELL} /home/jeed/workspace/cosme/build-aux/install-sh'
| libdir='${exec_prefix}/lib'
| libexecdir='${exec_prefix}/libexec'
| localedir='${datarootdir}/locale'
| localstatedir='${prefix}/var'
| mandir='${datarootdir}/man'
| mkdir_p='/bin/mkdir -p'
| oldincludedir='/usr/include'
| pdfdir='${docdir}'
| prefix='/usr/local'
| program_transform_name='s,x,x,'
| psdir='${docdir}'
| sbindir='${exec_prefix}/sbin'
| sharedstatedir='${prefix}/com'
| sysconfdir='${prefix}/etc'
| target_alias=''
| 
| ## ----------- ##
| ## confdefs.h. ##
| ## ----------- ##
| 
| /* confdefs.h */
| #define PACKAGE_NAME "Cosme"
| #define PACKAGE_TARNAME "cosme"
| #define PACKAGE_VERSION "0.7"
| #define PACKAGE_STRING "Cosme 0.7"
| #define PACKAGE_BUGREPORT "cosme@service-technology.org"
| #define PACKAGE_URL "http://service-technology.org/cosme"
| #define PACKAGE "cosme"
| #define VERSION "0.7"
| #define YYTEXT_POINTER 1
| #define VERSION_SVN "5755"
| #define CONFIG_BUILDSYSTEM "x86_64-unknown-linux-gnu"
| #define TOOL_AWK "\"gawk\""
| #define TOOL_GREP "\"/bin/grep\""
| #define HAVE_LIBPNAPI 1
| #define HAVE_MKTEMP 1
| #define HAVE_VFPRINTF 1
| #define HAVE_POPEN 1
| #define HAVE_PCLOSE 1
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| 
| configure: exit 0

