/*****************************************************************************\
 Maxis -- Construct maximal services

 Copyright (C) 2010  Jarungjit Parnjai <parnjai@informatik.hu-berlin.de>

 Maxis is free software: you can redistribute it and/or modify it under the
 terms of the GNU Affero General Public License as published by the Free
 Software Foundation, either version 3 of the License, or (at your option)
 any later version.

 Maxis is distributed in the hope that it will be useful, but WITHOUT ANY
 WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
 more details.

 You should have received a copy of the GNU Affero General Public License
 along with Maxis.  If not, see <http://www.gnu.org/licenses/>.
\*****************************************************************************/

#include <string>
#include <set>
#include <iostream>

#include "dnf.h"

using std::string;
using std::set;
using std::cerr;
using std::endl;

/*!
 * \brief constructor
 *
 * \note  if left or right child is also a conjunction,
 *        it will be merged with this node.
 */
PartialOrder::PartialOrder(Formula * f, set<string> & cl) : aFormula(f), clause(cl) {
	/* ... TODO ... */
}
/*!
 * \brief destructor
 *
 * \note  children will also be deleted.
 */
PartialOrder::~PartialOrder() {
	  for(set<PartialOrder *>::iterator it=poset.begin(); it != poset.end(); ++it) {
		 /* ...TODO : check if poset is not empty, then iteratively delete child ... */
	     delete (*it);
	  }
}

set<string> PartialOrder::get_conjunctive_string() const { return clause; }

set<PartialOrder *> PartialOrder::get_poset() const { return poset; }

void PartialOrder::insert_poset(PartialOrder *p) { poset.insert(p); }

void PartialOrder::remove_poset(PartialOrder *p) {
	/* ...TODO... */
}

std::ostream & PartialOrder::out(std::ostream & os) {
  os << "@ : ";

  for(set<string>::iterator it = clause.begin(); it!=clause.end(); ++it) {
	  os << *it << ", ";
  }
  os << endl;
  return os;
}

// constructor
DNF::DNF(Formula * f, set<string> & literals) :
		minimal(false), maximal(false), aFormula(f), all_literals(literals) {

	// root or partial order structure is always Literal "false"
	Literal * l = new Literal("false");
	set<string> l_clause = string_literals( l );
	po = new PartialOrder(static_cast<Formula *> (l), l_clause);

	// get all children elements of aFormula
	set<Formula *> children = aFormula->getElements();
	for(set<Formula *>::iterator it=children.begin(); it!=children.end(); ++it) {
		// assert : each children is either Literal or Conjunction
		set<string> child_clause;
		Formula * f = * it;
		Literal * l = dynamic_cast<Literal *> (f);
		if (l !=NULL) {
			child_clause.insert( l->getString() );
		} else {
			Conjunction * c = dynamic_cast<Conjunction *> (* it);
			if (c != NULL) {
				child_clause = conjunction_string_literals(c);
			}
		}
		if (!child_clause.empty()) {
			PartialOrder * child = new PartialOrder(f, child_clause);
			po->insert_poset( child );
		}
	}
}

// destructor
DNF::~DNF(){
	/* ...TODO... */
	set<PartialOrder *> children = po->get_poset();
	for(set<PartialOrder *>::iterator it=children.begin(); it!=children.end(); ++it) {
		delete(* it);
	}
	delete(po);
}

//PartialOrder & DNF::dfs() { //set<PartialOrder *> child) {
//	if (!child.empty()) {
//		for(set<ParitalOrder *>::iterator it=child.begin(); it!=child.end(); ++it) {
//			set<PartialOrder *> child_poset =
//			dfs(it-> );
//		}
//	}
//	detele
//	PartialOrder *p = new new PartialOrder(f, child_clause);
//	return & p;
//}

set<string> DNF::string_literals(const Literal * l) const {
	set<string> clause;
	clause.insert( l->getString() );
	return clause;
}

set<string> DNF::conjunction_string_literals(const Conjunction * c) const {
	set<string> clause;

	set<Formula *> children = c->getElements();
	for(set<Formula *>::iterator it=children.begin(); it!=children.end(); ++it)  {
		Literal * l = dynamic_cast<Literal *> (* it);
		if (l != NULL)
			clause.insert(l->getString());
	}
	return clause;
}

/// construct a minimal DNF
void DNF::minimize() { /* ...TODO... */ }

/// construct a complete DNF
void DNF::maximize() { /* ...TODO... */ }

/// does DNF cover a given conjunction
bool DNF::iscovered(const Conjunction &) const { return false; }

/// is the partial order set of DNF minimal
bool DNF::ismaximal() const {  return maximal; }

// is the partial order set of DNF maximal
bool DNF::isminimal() const { return minimal;  }

/*!
 * \brief write to stream
 */
std::ostream & DNF::out(std::ostream & os) {

//  os << "Formula :: " << aFormula << endl ;

  os << "[" << endl ;
  po->out(os);
  string delim = "";
//  set<string> children = po->get_conjunctive_string();
  set<PartialOrder *> child = po->get_poset();
  for(set<PartialOrder *>::iterator it=child.begin(); it!=child.end(); ++it) {
	  //os << delim;
	  (* it)->out(os) ;
	  //delim = ", ";
  }
  os << "]" << endl;
  return os;
}

