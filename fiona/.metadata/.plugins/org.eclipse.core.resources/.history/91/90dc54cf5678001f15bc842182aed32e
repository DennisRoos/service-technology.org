/*****************************************************************************\
 Maxis -- Construct maximal services

 Copyright (C) 2010  Jarungjit Parnjai <parnjai@informatik.hu-berlin.de>

 Maxis is free software: you can redistribute it and/or modify it under the
 terms of the GNU Affero General Public License as published by the Free
 Software Foundation, either version 3 of the License, or (at your option)
 any later version.

 Maxis is distributed in the hope that it will be useful, but WITHOUT ANY
 WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
 more details.

 You should have received a copy of the GNU Affero General Public License
 along with Maxis.  If not, see <http://www.gnu.org/licenses/>.
\*****************************************************************************/

#include <string>
#include <set>
#include <vector>
#include <stack>
#include <queue>
#include <iostream>
#include <sstream>
#include <cassert>

#include "dnf.h"
#include "util.h"

using std::string;
using std::set;
using std::stack;
using std::queue;
using std::vector;
using std::cerr;
using std::endl;
using std::pair;

/*!
 * \brief constructor
 *
 * \note  if left or right child is also a conjunction,
 *        it will be merged with this node.
 */
PartialOrder::PartialOrder(Formula * f, set<string> & cl) :
		aFormula(f->clone()), clause(cl) {
}
/*!
 * \brief destructor
 *
 * \note  children will also be deleted.
 */
PartialOrder::~PartialOrder() {
	delete(aFormula);
}

set<string> PartialOrder::get_conjunctive_string() const { return clause; }

set<PartialOrder *> PartialOrder::get_poset() const { return poset; }

bool PartialOrder::has_child() { return (!poset.empty()); }

void PartialOrder::insert_poset(PartialOrder *p) { poset.insert(p); }

void PartialOrder::remove_poset(PartialOrder *p)
{
	set<PartialOrder *>::iterator findit = poset.find(p);
	if (findit!=poset.end())
		poset.erase(p);
}

Formula * PartialOrder::get_aFormula() { return aFormula->clone(); }

std::ostream & PartialOrder::out(std::ostream & os) {
  os << "(";
  string delim = "";
  for(set<string>::iterator it=clause.begin(); it!=clause.end(); ++it) {
	  os << delim << it->data();
	  delim = ", ";
  }
  os << ") ";
  return os;
}


/* looks up search_string in the po structure
 * if the po structure already contains exact search string, then
 *    return the po pointers for both found_element and parent_element
 * otherwise,
 *    return found_element and parent element pointers for placing the search element
 */
pair<PartialOrder *, PartialOrder *> DNF::lookup(const PartialOrder * search_element) const {

	typedef pair<set<PartialOrder *>, set<PartialOrder *>::iterator > TraversePair;

	stack< TraversePair > lookupStack;
	set<PartialOrder *> neighbors = po->get_poset();
	set<PartialOrder *>::iterator neighbors_iterator = neighbors.begin();
	lookupStack.push(TraversePair (neighbors, neighbors_iterator));

	PartialOrder * found_element = po;
	PartialOrder * parent_element = po;
	set<string> temp_string = po->get_conjunctive_string();

	set<string> search_string = search_element->get_conjunctive_string();
	bool duplicated = false;

	while (!lookupStack.empty() && !duplicated)
	{
		TraversePair tpair = lookupStack.top();
		lookupStack.pop();
		set<PartialOrder *> temp_set = tpair.first;
		set<PartialOrder *>::iterator temp_iterator = tpair.second;

		while (temp_iterator != temp_set.end())
		{
			found_element = * temp_iterator;
			temp_string = found_element->get_conjunctive_string();
			temp_iterator++;

			bool superset = false;
			bool subset = false;
			pair<bool, bool> (superset, subset) = util::setRelation(temp_string, search_string);
			if (superset && subset) {
				// found a duplicate conjunction of literals
				duplicated = true;
				break;
			}
			if (superset && !subset) {
				// temp_string is a superset of search_string, traverse deeper
				if (temp_iterator != temp_set.end())
					lookupStack.push(TraversePair (temp_set, temp_iterator));

				set<PartialOrder *> children = found_element->get_poset();
				set<PartialOrder *>::iterator children_iterator = children.begin();
				lookupStack.push(TraversePair (children, children_iterator));
				parent_element = found_element;
				continue;
			}
			if (!superset && subset) {
				// temp_string is a subset of search_string, backtrack
				if (!lookupStack.empty()) { lookupStack.pop(); }
				break;
			}
			if (!superset && !subset) {
				// wrong path, backtrack
				if (!lookupStack.empty()) { lookupStack.pop(); }
				break;
			}
		}
	}

	if (duplicated) {
		found_element = po;
		parent_element = po;
	}

	return  pair<PartialOrder *, PartialOrder *> (found_element, parent_element);
}


/// constructor
DNF::DNF(Formula * f, set<string> & literals) :
		minimal(false), maximal(false), originalFormula(f->clone()), all_literals(literals), po(NULL)  {

	PartialOrder * found;
	PartialOrder * parent;

	// root or partial order structure is always Literal "false"
	string str = "false";
	Literal * l = new Literal(& str);
	set<string> l_clause;
	// l_clause of root node is always an empty string
	l_clause.insert(str);
	po = new PartialOrder(static_cast<Formula *> (l), l_clause);

	// get all children elements of an original Formula
	set<string> child_clause;
	Conjunction * c = dynamic_cast<Conjunction *> (originalFormula);
	if (c != NULL) {
		// assert : originalFormula contains only 1 clause of Conjunction
		child_clause = conjunction_string_literals(c);

		PartialOrder * child = new PartialOrder(f, child_clause);
		if (!po->has_child())  {
			po->insert_poset( child );
		} else {
			pair<PartialOrder *, PartialOrder *> ret = lookup(child);
			found = ret.first;
			parent = ret.second;
			if ((found !=  po ) && (parent != po)) {
				parent->insert_poset( child );
				child->insert_poset( found );
				parent->remove_poset( found );
			} else {
				po->insert_poset( child );
			}
		}
		disjuncts.insert(originalFormula);
	} else {
		set<Formula *> children = originalFormula->getElements();
		for(set<Formula *>::iterator it=children.begin(); it!=children.end(); ++it) {

			// assert : each children is either Literal or Conjunction
			Formula * f = * it;
			Literal * l = dynamic_cast<Literal *> (f);
			if (l != NULL) {
				child_clause.insert( l->getString() );
			} else {
				c = dynamic_cast<Conjunction *> (f);
				if (c != NULL) {
					child_clause = conjunction_string_literals(c);
				}
			}

			if (!child_clause.empty()) {
				// alternatively, one can check if it is a multiple conjunction
				PartialOrder * child = new PartialOrder(f, child_clause);
				if (!po->has_child()) {
					po->insert_poset( child );
				} else {
					pair<PartialOrder *, PartialOrder *> ret = lookup(child);
					found = ret.first;
					parent = ret.second;
					if (found != po && parent != po) {
						parent->insert_poset( child );
						child->insert_poset( found );
						parent->remove_poset( found );
					} else {
						po->insert_poset( child );
					}
				}
			}
			child_clause.clear();
			disjuncts.insert(f);
		}  /* end iterator */
	}

}

// destructor
DNF::~DNF(){
	traverseDelete(po);
	disjuncts.clear();
	all_literals.clear();
}


void DNF::traverseDelete(PartialOrder * node)
{
	set<PartialOrder *> children = node->get_poset();
	for(set<PartialOrder *>::iterator it=children.begin(); it!=children.end(); ++it) {
		traverseDelete( *it );
	}
    delete(node);
}

set<string> DNF::conjunction_string_literals(const Conjunction * c) const {
	set<string> clause;

	set<Formula *> children = c->getElements();
	for(set<Formula *>::iterator it=children.begin(); it!=children.end(); ++it)  {
		Literal * l = dynamic_cast<Literal *> (* it);
		if (l != NULL)
			clause.insert(l->getString());
	}
	return clause;
}

/// construct a minimal DNF
void DNF::minimize(std::ostream & os) {
	/* ...TODO... */
	/* (a * false) = false, i.e, a will be removed
	   (a * true) = a, i.e., true will be removed
	   false + a + false = a + false, i.e., false will be removed
	   disbjunction of all literals = true
	 */

	set<PartialOrder *> children = po->get_poset();
	po->out(os);
	for(set<PartialOrder *>::iterator it=children.begin(); it!=children.end(); ++it) {
		set<PartialOrder *> grandChildren = (*it)->get_poset();
		for(set<PartialOrder *>::iterator git=grandChildren.begin(); git!=grandChildren.end(); ++git) {
			(*git)->out(os);
			traverseDelete( *git );
		}
	}
}

/// construct a complete DNF
void DNF::maximize()
{
	/* ...TODO... */
}

/// does DNF cover a given conjunction
bool DNF::is_covered(const Conjunction &) const { return false; }

/// is the partial order set of DNF minimal
bool DNF::is_maximal() const {  return maximal; }

// is the partial order set of DNF maximal
bool DNF::is_minimal() const { return minimal;  }

/* write DNF output
 */
Disjunction * DNF::get_DNF()
{
 	Disjunction * aFormula = new Disjunction(disjuncts);
    return aFormula;
}

/*!
 * \brief write to stream
 */
std::ostream & DNF::out(std::ostream & os)
{
	// po->out(os);
	std::ostringstream oss;
	os << "[" << traverseOutput(oss, po).str() << "]" << endl;
    return os;
}

/* preorder traversal
 */
std::ostringstream & DNF::traverseOutput(std::ostringstream & oss, PartialOrder * node)
{
	(node)->out(oss) << ", ";
    set<PartialOrder *> child = node->get_poset();
	for(set<PartialOrder *>::iterator cit=child.begin(); cit!=child.end(); ++cit) {
		traverseOutput(oss, *cit);
	}
	return oss;
}

/*std::ostringstream & DNF::postorder(std::ostringstream & oss, PartialOrder * node)
{
    set<PartialOrder *> child = node->get_poset();
	for(set<PartialOrder *>::iterator cit=child.begin(); cit!=child.end(); ++cit) {
		preorder(oss, *cit);
	}
	(node)->out(oss) << ", ";
	return oss;
}
*/
