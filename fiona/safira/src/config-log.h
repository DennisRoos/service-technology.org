/// the content of the file 'config.log' generated by the configure script
#define CONFIG_LOG \
"This file contains any messages produced by compilers while\n"\
"running configure, to aid debugging if configure makes a mistake.\n"\
"\n"\
"It was created by Safira configure 2.0, which was\n"\
"generated by GNU Autoconf 2.65.  Invocation command line was\n"\
"\n"\
"  $ ./configure \n"\
"\n"\
"## --------- ##\n"\
"## Platform. ##\n"\
"## --------- ##\n"\
"\n"\
"hostname = SomTam\n"\
"uname -m = x86_64\n"\
"uname -r = 2.6.32-22-generic\n"\
"uname -s = Linux\n"\
"uname -v = #33-Ubuntu SMP Wed Apr 28 13:28:05 UTC 2010\n"\
"\n"\
"/usr/bin/uname -p = unknown\n"\
"/bin/uname -X     = unknown\n"\
"\n"\
"/bin/arch              = unknown\n"\
"/usr/bin/arch -k       = unknown\n"\
"/usr/convex/getsysinfo = unknown\n"\
"/usr/bin/hostinfo      = unknown\n"\
"/bin/machine           = unknown\n"\
"/usr/bin/oslevel       = unknown\n"\
"/bin/universe          = unknown\n"\
"\n"\
"PATH: /usr/local/sbin\n"\
"PATH: /usr/local/bin\n"\
"PATH: /usr/sbin\n"\
"PATH: /usr/bin\n"\
"PATH: /sbin\n"\
"PATH: /bin\n"\
"PATH: /usr/games\n"\
"\n"\
"\n"\
"## ----------- ##\n"\
"## Core tests. ##\n"\
"## ----------- ##\n"\
"\n"\
"configure:1953:  ____         __ _           \n"\
"configure:1955: / ___|  __ _ / _(_)_ __ __ _ \n"\
"configure:1957: \\___ \\ / _` | |_| | '__/ _` |\n"\
"configure:1959:  ___) | (_| |  _| | | | (_| |\n"\
"configure:1961: |____/ \\__,_|_| |_|_|  \\__,_|\n"\
"configure:1963: implementing set algebra for service behavior\n"\
"configure:1965: http://service-technology.org/safira\n"\
"configure:1967: version 2.0\n"\
"configure:1969: \n"\
"configure:2015: checking for a BSD-compatible install\n"\
"configure:2083: result: /usr/bin/install -c\n"\
"configure:2094: checking whether build environment is sane\n"\
"configure:2144: result: yes\n"\
"configure:2285: checking for a thread-safe mkdir -p\n"\
"configure:2324: result: /bin/mkdir -p\n"\
"configure:2337: checking for gawk\n"\
"configure:2353: found /usr/bin/gawk\n"\
"configure:2364: result: gawk\n"\
"configure:2375: checking whether make sets $(MAKE)\n"\
"configure:2397: result: yes\n"\
"configure:2549: checking for g++\n"\
"configure:2565: found /usr/bin/g++\n"\
"configure:2576: result: g++\n"\
"configure:2603: checking for C++ compiler version\n"\
"configure:2612: g++ --version >&5\n"\
"g++ (Ubuntu 4.4.3-4ubuntu5) 4.4.3\n"\
"Copyright (C) 2009 Free Software Foundation, Inc.\n"\
"This is free software; see the source for copying conditions.  There is NO\n"\
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"\
"\n"\
"configure:2623: $? = 0\n"\
"configure:2612: g++ -v >&5\n"\
"Using built-in specs.\n"\
"Target: x86_64-linux-gnu\n"\
"Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu\n"\
"Thread model: posix\n"\
"gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5) \n"\
"configure:2623: $? = 0\n"\
"configure:2612: g++ -V >&5\n"\
"g++: '-V' option must have argument\n"\
"configure:2623: $? = 1\n"\
"configure:2612: g++ -qversion >&5\n"\
"g++: unrecognized option '-qversion'\n"\
"g++: no input files\n"\
"configure:2623: $? = 1\n"\
"configure:2643: checking whether the C++ compiler works\n"\
"configure:2665: g++    conftest.cpp  >&5\n"\
"configure:2669: $? = 0\n"\
"configure:2718: result: yes\n"\
"configure:2721: checking for C++ compiler default output file name\n"\
"configure:2723: result: a.out\n"\
"configure:2729: checking for suffix of executables\n"\
"configure:2736: g++ -o conftest    conftest.cpp  >&5\n"\
"configure:2740: $? = 0\n"\
"configure:2762: result: \n"\
"configure:2784: checking whether we are cross compiling\n"\
"configure:2792: g++ -o conftest    conftest.cpp  >&5\n"\
"configure:2796: $? = 0\n"\
"configure:2803: ./conftest\n"\
"configure:2807: $? = 0\n"\
"configure:2822: result: no\n"\
"configure:2827: checking for suffix of object files\n"\
"configure:2849: g++ -c   conftest.cpp >&5\n"\
"configure:2853: $? = 0\n"\
"configure:2874: result: o\n"\
"configure:2878: checking whether we are using the GNU C++ compiler\n"\
"configure:2897: g++ -c   conftest.cpp >&5\n"\
"configure:2897: $? = 0\n"\
"configure:2906: result: yes\n"\
"configure:2915: checking whether g++ accepts -g\n"\
"configure:2935: g++ -c -g  conftest.cpp >&5\n"\
"configure:2935: $? = 0\n"\
"configure:2976: result: yes\n"\
"configure:3010: checking for style of include used by make\n"\
"configure:3038: result: GNU\n"\
"configure:3063: checking dependency style of g++\n"\
"configure:3173: result: gcc3\n"\
"configure:3236: checking for gcc\n"\
"configure:3252: found /usr/bin/gcc\n"\
"configure:3263: result: gcc\n"\
"configure:3492: checking for C compiler version\n"\
"configure:3501: gcc --version >&5\n"\
"gcc (Ubuntu 4.4.3-4ubuntu5) 4.4.3\n"\
"Copyright (C) 2009 Free Software Foundation, Inc.\n"\
"This is free software; see the source for copying conditions.  There is NO\n"\
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"\
"\n"\
"configure:3512: $? = 0\n"\
"configure:3501: gcc -v >&5\n"\
"Using built-in specs.\n"\
"Target: x86_64-linux-gnu\n"\
"Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu\n"\
"Thread model: posix\n"\
"gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5) \n"\
"configure:3512: $? = 0\n"\
"configure:3501: gcc -V >&5\n"\
"gcc: '-V' option must have argument\n"\
"configure:3512: $? = 1\n"\
"configure:3501: gcc -qversion >&5\n"\
"gcc: unrecognized option '-qversion'\n"\
"gcc: no input files\n"\
"configure:3512: $? = 1\n"\
"configure:3516: checking whether we are using the GNU C compiler\n"\
"configure:3535: gcc -c   conftest.c >&5\n"\
"configure:3535: $? = 0\n"\
"configure:3544: result: yes\n"\
"configure:3553: checking whether gcc accepts -g\n"\
"configure:3573: gcc -c -g  conftest.c >&5\n"\
"configure:3573: $? = 0\n"\
"configure:3614: result: yes\n"\
"configure:3631: checking for gcc option to accept ISO C89\n"\
"configure:3695: gcc  -c -g -O2  conftest.c >&5\n"\
"configure:3695: $? = 0\n"\
"configure:3708: result: none needed\n"\
"configure:3730: checking dependency style of gcc\n"\
"configure:3840: result: gcc3\n"\
"configure:3856: checking whether gcc and cc understand -c and -o together\n"\
"configure:3887: gcc -c conftest.c -o conftest2.o >&5\n"\
"configure:3891: $? = 0\n"\
"configure:3897: gcc -c conftest.c -o conftest2.o >&5\n"\
"configure:3901: $? = 0\n"\
"configure:3912: cc -c conftest.c >&5\n"\
"configure:3916: $? = 0\n"\
"configure:3924: cc -c conftest.c -o conftest2.o >&5\n"\
"configure:3928: $? = 0\n"\
"configure:3934: cc -c conftest.c -o conftest2.o >&5\n"\
"configure:3938: $? = 0\n"\
"configure:3956: result: yes\n"\
"configure:3986: checking for flex\n"\
"configure:4002: found /usr/bin/flex\n"\
"configure:4013: result: flex\n"\
"configure:4050: flex conftest.l\n"\
"configure:4054: $? = 0\n"\
"configure:4056: checking lex output file root\n"\
"configure:4070: result: lex.yy\n"\
"configure:4075: checking lex library\n"\
"configure:4089: gcc -o conftest -g -O2   conftest.c   >&5\n"\
"/tmp/cc9oVRv3.o: In function `input':\n"\
"/home/jeed/workspace/safira/lex.yy.c:1182: undefined reference to `yywrap'\n"\
"/tmp/cc9oVRv3.o: In function `yylex':\n"\
"/home/jeed/workspace/safira/lex.yy.c:881: undefined reference to `yywrap'\n"\
"/tmp/cc9oVRv3.o: In function `main':\n"\
"/home/jeed/workspace/safira/conftest.l:17: undefined reference to `yywrap'\n"\
"collect2: ld returned 1 exit status\n"\
"configure:4089: $? = 1\n"\
"configure: failed program was:\n"\
"| /* confdefs.h */\n"\
"| #define PACKAGE_NAME \"Safira\"\n"\
"| #define PACKAGE_TARNAME \"safira\"\n"\
"| #define PACKAGE_VERSION \"2.0\"\n"\
"| #define PACKAGE_STRING \"Safira 2.0\"\n"\
"| #define PACKAGE_BUGREPORT \"safira@service-technology.org\"\n"\
"| #define PACKAGE_URL \"http://service-technology.org/safira\"\n"\
"| #define PACKAGE \"safira\"\n"\
"| #define VERSION \"2.0\"\n"\
"| /* end confdefs.h.  */\n"\
"| \n"\
"| #line 3 \"lex.yy.c\"\n"\
"| \n"\
"| #define  YY_INT_ALIGNED short int\n"\
"| \n"\
"| /* A lexical scanner generated by flex */\n"\
"| \n"\
"| #define FLEX_SCANNER\n"\
"| #define YY_FLEX_MAJOR_VERSION 2\n"\
"| #define YY_FLEX_MINOR_VERSION 5\n"\
"| #define YY_FLEX_SUBMINOR_VERSION 35\n"\
"| #if YY_FLEX_SUBMINOR_VERSION > 0\n"\
"| #define FLEX_BETA\n"\
"| #endif\n"\
"| \n"\
"| /* First, we deal with  platform-specific or compiler-specific issues. */\n"\
"| \n"\
"| /* begin standard C headers. */\n"\
"| #include <stdio.h>\n"\
"| #include <string.h>\n"\
"| #include <errno.h>\n"\
"| #include <stdlib.h>\n"\
"| \n"\
"| /* end standard C headers. */\n"\
"| \n"\
"| /* flex integer type definitions */\n"\
"| \n"\
"| #ifndef FLEXINT_H\n"\
"| #define FLEXINT_H\n"\
"| \n"\
"| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */\n"\
"| \n"\
"| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n"\
"| \n"\
"| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,\n"\
"|  * if you want the limit (max/min) macros for int types. \n"\
"|  */\n"\
"| #ifndef __STDC_LIMIT_MACROS\n"\
"| #define __STDC_LIMIT_MACROS 1\n"\
"| #endif\n"\
"| \n"\
"| #include <inttypes.h>\n"\
"| typedef int8_t flex_int8_t;\n"\
"| typedef uint8_t flex_uint8_t;\n"\
"| typedef int16_t flex_int16_t;\n"\
"| typedef uint16_t flex_uint16_t;\n"\
"| typedef int32_t flex_int32_t;\n"\
"| typedef uint32_t flex_uint32_t;\n"\
"| #else\n"\
"| typedef signed char flex_int8_t;\n"\
"| typedef short int flex_int16_t;\n"\
"| typedef int flex_int32_t;\n"\
"| typedef unsigned char flex_uint8_t; \n"\
"| typedef unsigned short int flex_uint16_t;\n"\
"| typedef unsigned int flex_uint32_t;\n"\
"| \n"\
"| /* Limits of integral types. */\n"\
"| #ifndef INT8_MIN\n"\
"| #define INT8_MIN               (-128)\n"\
"| #endif\n"\
"| #ifndef INT16_MIN\n"\
"| #define INT16_MIN              (-32767-1)\n"\
"| #endif\n"\
"| #ifndef INT32_MIN\n"\
"| #define INT32_MIN              (-2147483647-1)\n"\
"| #endif\n"\
"| #ifndef INT8_MAX\n"\
"| #define INT8_MAX               (127)\n"\
"| #endif\n"\
"| #ifndef INT16_MAX\n"\
"| #define INT16_MAX              (32767)\n"\
"| #endif\n"\
"| #ifndef INT32_MAX\n"\
"| #define INT32_MAX              (2147483647)\n"\
"| #endif\n"\
"| #ifndef UINT8_MAX\n"\
"| #define UINT8_MAX              (255U)\n"\
"| #endif\n"\
"| #ifndef UINT16_MAX\n"\
"| #define UINT16_MAX             (65535U)\n"\
"| #endif\n"\
"| #ifndef UINT32_MAX\n"\
"| #define UINT32_MAX             (4294967295U)\n"\
"| #endif\n"\
"| \n"\
"| #endif /* ! C99 */\n"\
"| \n"\
"| #endif /* ! FLEXINT_H */\n"\
"| \n"\
"| #ifdef __cplusplus\n"\
"| \n"\
"| /* The \"const\" storage-class-modifier is valid. */\n"\
"| #define YY_USE_CONST\n"\
"| \n"\
"| #else	/* ! __cplusplus */\n"\
"| \n"\
"| /* C99 requires __STDC__ to be defined as 1. */\n"\
"| #if defined (__STDC__)\n"\
"| \n"\
"| #define YY_USE_CONST\n"\
"| \n"\
"| #endif	/* defined (__STDC__) */\n"\
"| #endif	/* ! __cplusplus */\n"\
"| \n"\
"| #ifdef YY_USE_CONST\n"\
"| #define yyconst const\n"\
"| #else\n"\
"| #define yyconst\n"\
"| #endif\n"\
"| \n"\
"| /* Returned upon end-of-file. */\n"\
"| #define YY_NULL 0\n"\
"| \n"\
"| /* Promotes a possibly negative, possibly signed char to an unsigned\n"\
"|  * integer for use as an array index.  If the signed char is negative,\n"\
"|  * we want to instead treat it as an 8-bit unsigned char, hence the\n"\
"|  * double cast.\n"\
"|  */\n"\
"| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\n"\
"| \n"\
"| /* Enter a start condition.  This macro really ought to take a parameter,\n"\
"|  * but we do it the disgusting crufty way forced on us by the ()-less\n"\
"|  * definition of BEGIN.\n"\
"|  */\n"\
"| #define BEGIN (yy_start) = 1 + 2 *\n"\
"| \n"\
"| /* Translate the current start state into a value that can be later handed\n"\
"|  * to BEGIN to return to the state.  The YYSTATE alias is for lex\n"\
"|  * compatibility.\n"\
"|  */\n"\
"| #define YY_START (((yy_start) - 1) / 2)\n"\
"| #define YYSTATE YY_START\n"\
"| \n"\
"| /* Action number for EOF rule of a given start state. */\n"\
"| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n"\
"| \n"\
"| /* Special action meaning \"start processing a new file\". */\n"\
"| #define YY_NEW_FILE yyrestart(yyin  )\n"\
"| \n"\
"| #define YY_END_OF_BUFFER_CHAR 0\n"\
"| \n"\
"| /* Size of default input buffer. */\n"\
"| #ifndef YY_BUF_SIZE\n"\
"| #ifdef __ia64__\n"\
"| /* On IA-64, the buffer size is 16k, not 8k.\n"\
"|  * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n"\
"|  * Ditto for the __ia64__ case accordingly.\n"\
"|  */\n"\
"| #define YY_BUF_SIZE 32768\n"\
"| #else\n"\
"| #define YY_BUF_SIZE 16384\n"\
"| #endif /* __ia64__ */\n"\
"| #endif\n"\
"| \n"\
"| /* The state buf must be large enough to hold one state per character in the main buffer.\n"\
"|  */\n"\
"| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))\n"\
"| \n"\
"| #ifndef YY_TYPEDEF_YY_BUFFER_STATE\n"\
"| #define YY_TYPEDEF_YY_BUFFER_STATE\n"\
"| typedef struct yy_buffer_state *YY_BUFFER_STATE;\n"\
"| #endif\n"\
"| \n"\
"| extern int yyleng;\n"\
"| \n"\
"| extern FILE *yyin, *yyout;\n"\
"| \n"\
"| #define EOB_ACT_CONTINUE_SCAN 0\n"\
"| #define EOB_ACT_END_OF_FILE 1\n"\
"| #define EOB_ACT_LAST_MATCH 2\n"\
"| \n"\
"|     #define YY_LESS_LINENO(n)\n"\
"|     \n"\
"| /* Return all but the first \"n\" matched characters back to the input stream. */\n"\
"| #define yyless(n) \\\n"\
"| 	do \\\n"\
"| 		{ \\\n"\
"| 		/* Undo effects of setting up yytext. */ \\\n"\
"|         int yyless_macro_arg = (n); \\\n"\
"|         YY_LESS_LINENO(yyless_macro_arg);\\\n"\
"| 		*yy_cp = (yy_hold_char); \\\n"\
"| 		YY_RESTORE_YY_MORE_OFFSET \\\n"\
"| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \\\n"\
"| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n"\
"| 		} \\\n"\
"| 	while ( 0 )\n"\
"| \n"\
"| #define unput(c) yyunput( c, (yytext_ptr)  )\n"\
"| \n"\
"| #ifndef YY_TYPEDEF_YY_SIZE_T\n"\
"| #define YY_TYPEDEF_YY_SIZE_T\n"\
"| typedef size_t yy_size_t;\n"\
"| #endif\n"\
"| \n"\
"| #ifndef YY_STRUCT_YY_BUFFER_STATE\n"\
"| #define YY_STRUCT_YY_BUFFER_STATE\n"\
"| struct yy_buffer_state\n"\
"| 	{\n"\
"| 	FILE *yy_input_file;\n"\
"| \n"\
"| 	char *yy_ch_buf;		/* input buffer */\n"\
"| 	char *yy_buf_pos;		/* current position in input buffer */\n"\
"| \n"\
"| 	/* Size of input buffer in bytes, not including room for EOB\n"\
"| 	 * characters.\n"\
"| 	 */\n"\
"| 	yy_size_t yy_buf_size;\n"\
"| \n"\
"| 	/* Number of characters read into yy_ch_buf, not including EOB\n"\
"| 	 * characters.\n"\
"| 	 */\n"\
"| 	int yy_n_chars;\n"\
"| \n"\
"| 	/* Whether we \"own\" the buffer - i.e., we know we created it,\n"\
"| 	 * and can realloc() it to grow it, and should free() it to\n"\
"| 	 * delete it.\n"\
"| 	 */\n"\
"| 	int yy_is_our_buffer;\n"\
"| \n"\
"| 	/* Whether this is an \"interactive\" input source; if so, and\n"\
"| 	 * if we're using stdio for input, then we want to use getc()\n"\
"| 	 * instead of fread(), to make sure we stop fetching input after\n"\
"| 	 * each newline.\n"\
"| 	 */\n"\
"| 	int yy_is_interactive;\n"\
"| \n"\
"| 	/* Whether we're considered to be at the beginning of a line.\n"\
"| 	 * If so, '^' rules will be active on the next match, otherwise\n"\
"| 	 * not.\n"\
"| 	 */\n"\
"| 	int yy_at_bol;\n"\
"| \n"\
"|     int yy_bs_lineno; /**< The line count. */\n"\
"|     int yy_bs_column; /**< The column count. */\n"\
"|     \n"\
"| 	/* Whether to try to fill the input buffer when we reach the\n"\
"| 	 * end of it.\n"\
"| 	 */\n"\
"| 	int yy_fill_buffer;\n"\
"| \n"\
"| 	int yy_buffer_status;\n"\
"| \n"\
"| #define YY_BUFFER_NEW 0\n"\
"| #define YY_BUFFER_NORMAL 1\n"\
"| 	/* When an EOF's been seen but there's still some text to process\n"\
"| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n"\
"| 	 * shouldn't try reading from the input source any more.  We might\n"\
"| 	 * still have a bunch of tokens to match, though, because of\n"\
"| 	 * possible backing-up.\n"\
"| 	 *\n"\
"| 	 * When we actually see the EOF, we change the status to \"new\"\n"\
"| 	 * (via yyrestart()), so that the user can continue scanning by\n"\
"| 	 * just pointing yyin at a new input file.\n"\
"| 	 */\n"\
"| #define YY_BUFFER_EOF_PENDING 2\n"\
"| \n"\
"| 	};\n"\
"| #endif /* !YY_STRUCT_YY_BUFFER_STATE */\n"\
"| \n"\
"| /* Stack of input buffers. */\n"\
"| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */\n"\
"| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */\n"\
"| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */\n"\
"| \n"\
"| /* We provide macros for accessing buffer states in case in the\n"\
"|  * future we want to put the buffer states in a more general\n"\
"|  * \"scanner state\".\n"\
"|  *\n"\
"|  * Returns the top of the stack, or NULL.\n"\
"|  */\n"\
"| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \\\n"\
"|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \\\n"\
"|                           : NULL)\n"\
"| \n"\
"| /* Same as previous macro, but useful when we know that the buffer stack is not\n"\
"|  * NULL or when we need an lvalue. For internal use only.\n"\
"|  */\n"\
"| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]\n"\
"| \n"\
"| /* yy_hold_char holds the character lost when yytext is formed. */\n"\
"| static char yy_hold_char;\n"\
"| static int yy_n_chars;		/* number of characters read into yy_ch_buf */\n"\
"| int yyleng;\n"\
"| \n"\
"| /* Points to current character in buffer. */\n"\
"| static char *yy_c_buf_p = (char *) 0;\n"\
"| static int yy_init = 0;		/* whether we need to initialize */\n"\
"| static int yy_start = 0;	/* start state number */\n"\
"| \n"\
"| /* Flag which is used to allow yywrap()'s to do buffer switches\n"\
"|  * instead of setting up a fresh yyin.  A bit of a hack ...\n"\
"|  */\n"\
"| static int yy_did_buffer_switch_on_eof;\n"\
"| \n"\
"| void yyrestart (FILE *input_file  );\n"\
"| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );\n"\
"| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );\n"\
"| void yy_delete_buffer (YY_BUFFER_STATE b  );\n"\
"| void yy_flush_buffer (YY_BUFFER_STATE b  );\n"\
"| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );\n"\
"| void yypop_buffer_state (void );\n"\
"| \n"\
"| static void yyensure_buffer_stack (void );\n"\
"| static void yy_load_buffer_state (void );\n"\
"| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );\n"\
"| \n"\
"| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )\n"\
"| \n"\
"| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );\n"\
"| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );\n"\
"| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );\n"\
"| \n"\
"| void *yyalloc (yy_size_t  );\n"\
"| void *yyrealloc (void *,yy_size_t  );\n"\
"| void yyfree (void *  );\n"\
"| \n"\
"| #define yy_new_buffer yy_create_buffer\n"\
"| \n"\
"| #define yy_set_interactive(is_interactive) \\\n"\
"| 	{ \\\n"\
"| 	if ( ! YY_CURRENT_BUFFER ){ \\\n"\
"|         yyensure_buffer_stack (); \\\n"\
"| 		YY_CURRENT_BUFFER_LVALUE =    \\\n"\
"|             yy_create_buffer(yyin,YY_BUF_SIZE ); \\\n"\
"| 	} \\\n"\
"| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \\\n"\
"| 	}\n"\
"| \n"\
"| #define yy_set_bol(at_bol) \\\n"\
"| 	{ \\\n"\
"| 	if ( ! YY_CURRENT_BUFFER ){\\\n"\
"|         yyensure_buffer_stack (); \\\n"\
"| 		YY_CURRENT_BUFFER_LVALUE =    \\\n"\
"|             yy_create_buffer(yyin,YY_BUF_SIZE ); \\\n"\
"| 	} \\\n"\
"| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \\\n"\
"| 	}\n"\
"| \n"\
"| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)\n"\
"| \n"\
"| /* Begin user sect3 */\n"\
"| \n"\
"| typedef unsigned char YY_CHAR;\n"\
"| \n"\
"| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;\n"\
"| \n"\
"| typedef int yy_state_type;\n"\
"| \n"\
"| extern int yylineno;\n"\
"| \n"\
"| int yylineno = 1;\n"\
"| \n"\
"| extern char *yytext;\n"\
"| #define yytext_ptr yytext\n"\
"| \n"\
"| static yy_state_type yy_get_previous_state (void );\n"\
"| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );\n"\
"| static int yy_get_next_buffer (void );\n"\
"| static void yy_fatal_error (yyconst char msg[]  );\n"\
"| \n"\
"| /* Done after the current pattern has been matched and before the\n"\
"|  * corresponding action - sets up yytext.\n"\
"|  */\n"\
"| #define YY_DO_BEFORE_ACTION \\\n"\
"| 	(yytext_ptr) = yy_bp; \\\n"\
"| 	(yytext_ptr) -= (yy_more_len); \\\n"\
"| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \\\n"\
"| 	(yy_hold_char) = *yy_cp; \\\n"\
"| 	*yy_cp = '\\0'; \\\n"\
"| 	(yy_c_buf_p) = yy_cp;\n"\
"| \n"\
"| #define YY_NUM_RULES 8\n"\
"| #define YY_END_OF_BUFFER 9\n"\
"| /* This struct is not used in this scanner,\n"\
"|    but its presence is necessary. */\n"\
"| struct yy_trans_info\n"\
"| 	{\n"\
"| 	flex_int32_t yy_verify;\n"\
"| 	flex_int32_t yy_nxt;\n"\
"| 	};\n"\
"| static yyconst flex_int16_t yy_acclist[23] =\n"\
"|     {   0,\n"\
"|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,\n"\
"|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,\n"\
"|         7,    8\n"\
"|     } ;\n"\
"| \n"\
"| static yyconst flex_int16_t yy_accept[14] =\n"\
"|     {   0,\n"\
"|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,\n"\
"|        20,   23,   23\n"\
"|     } ;\n"\
"| \n"\
"| static yyconst flex_int32_t yy_ec[256] =\n"\
"|     {   0,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,\n"\
"| \n"\
"|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"| \n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n"\
"|         1,    1,    1,    1,    1\n"\
"|     } ;\n"\
"| \n"\
"| static yyconst flex_int32_t yy_meta[9] =\n"\
"|     {   0,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1\n"\
"|     } ;\n"\
"| \n"\
"| static yyconst flex_int16_t yy_base[13] =\n"\
"|     {   0,\n"\
"|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,\n"\
"|        10,   10\n"\
"|     } ;\n"\
"| \n"\
"| static yyconst flex_int16_t yy_def[13] =\n"\
"|     {   0,\n"\
"|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,\n"\
"|        12,    0\n"\
"|     } ;\n"\
"| \n"\
"| static yyconst flex_int16_t yy_nxt[19] =\n"\
"|     {   0,\n"\
"|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,\n"\
"|        12,   12,   12,   12,   12,   12,   12,   12\n"\
"|     } ;\n"\
"| \n"\
"| static yyconst flex_int16_t yy_chk[19] =\n"\
"|     {   0,\n"\
"|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,\n"\
"|        12,   12,   12,   12,   12,   12,   12,   12\n"\
"|     } ;\n"\
"| \n"\
"| extern int yy_flex_debug;\n"\
"| int yy_flex_debug = 0;\n"\
"| \n"\
"| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;\n"\
"| static char *yy_full_match;\n"\
"| static int yy_lp;\n"\
"| #define REJECT \\\n"\
"| { \\\n"\
"| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \\\n"\
"| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \\\n"\
"| ++(yy_lp); \\\n"\
"| goto find_rule; \\\n"\
"| }\n"\
"| \n"\
"| static int yy_more_flag = 0;\n"\
"| static int yy_more_len = 0;\n"\
"| #define yymore() ((yy_more_flag) = 1)\n"\
"| #define YY_MORE_ADJ (yy_more_len)\n"\
"| #define YY_RESTORE_YY_MORE_OFFSET\n"\
"| char *yytext;\n"\
"| #line 1 \"conftest.l\"\n"\
"| #line 477 \"lex.yy.c\"\n"\
"| \n"\
"| #define INITIAL 0\n"\
"| \n"\
"| #ifndef YY_NO_UNISTD_H\n"\
"| /* Special case for \"unistd.h\", since it is non-ANSI. We include it way\n"\
"|  * down here because we want the user's section 1 to have been scanned first.\n"\
"|  * The user has a chance to override it with an option.\n"\
"|  */\n"\
"| #include <unistd.h>\n"\
"| #endif\n"\
"| \n"\
"| #ifndef YY_EXTRA_TYPE\n"\
"| #define YY_EXTRA_TYPE void *\n"\
"| #endif\n"\
"| \n"\
"| static int yy_init_globals (void );\n"\
"| \n"\
"| /* Accessor methods to globals.\n"\
"|    These are made visible to non-reentrant scanners for convenience. */\n"\
"| \n"\
"| int yylex_destroy (void );\n"\
"| \n"\
"| int yyget_debug (void );\n"\
"| \n"\
"| void yyset_debug (int debug_flag  );\n"\
"| \n"\
"| YY_EXTRA_TYPE yyget_extra (void );\n"\
"| \n"\
"| void yyset_extra (YY_EXTRA_TYPE user_defined  );\n"\
"| \n"\
"| FILE *yyget_in (void );\n"\
"| \n"\
"| void yyset_in  (FILE * in_str  );\n"\
"| \n"\
"| FILE *yyget_out (void );\n"\
"| \n"\
"| void yyset_out  (FILE * out_str  );\n"\
"| \n"\
"| int yyget_leng (void );\n"\
"| \n"\
"| char *yyget_text (void );\n"\
"| \n"\
"| int yyget_lineno (void );\n"\
"| \n"\
"| void yyset_lineno (int line_number  );\n"\
"| \n"\
"| /* Macros after this point can all be overridden by user definitions in\n"\
"|  * section 1.\n"\
"|  */\n"\
"| \n"\
"| #ifndef YY_SKIP_YYWRAP\n"\
"| #ifdef __cplusplus\n"\
"| extern \"C\" int yywrap (void );\n"\
"| #else\n"\
"| extern int yywrap (void );\n"\
"| #endif\n"\
"| #endif\n"\
"| \n"\
"|     static void yyunput (int c,char *buf_ptr  );\n"\
"|     \n"\
"| #ifndef yytext_ptr\n"\
"| static void yy_flex_strncpy (char *,yyconst char *,int );\n"\
"| #endif\n"\
"| \n"\
"| #ifdef YY_NEED_STRLEN\n"\
"| static int yy_flex_strlen (yyconst char * );\n"\
"| #endif\n"\
"| \n"\
"| #ifndef YY_NO_INPUT\n"\
"| \n"\
"| #ifdef __cplusplus\n"\
"| static int yyinput (void );\n"\
"| #else\n"\
"| static int input (void );\n"\
"| #endif\n"\
"| \n"\
"| #endif\n"\
"| \n"\
"| /* Amount of stuff to slurp up with each read. */\n"\
"| #ifndef YY_READ_BUF_SIZE\n"\
"| #ifdef __ia64__\n"\
"| /* On IA-64, the buffer size is 16k, not 8k */\n"\
"| #define YY_READ_BUF_SIZE 16384\n"\
"| #else\n"\
"| #define YY_READ_BUF_SIZE 8192\n"\
"| #endif /* __ia64__ */\n"\
"| #endif\n"\
"| \n"\
"| /* Copy whatever the last rule matched to the standard output. */\n"\
"| #ifndef ECHO\n"\
"| /* This used to be an fputs(), but since the string might contain NUL's,\n"\
"|  * we now use fwrite().\n"\
"|  */\n"\
"| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)\n"\
"| #endif\n"\
"| \n"\
"| /* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n"\
"|  * is returned in \"result\".\n"\
"|  */\n"\
"| #ifndef YY_INPUT\n"\
"| #define YY_INPUT(buf,result,max_size) \\\n"\
"| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\\n"\
"| 		{ \\\n"\
"| 		int c = '*'; \\\n"\
"| 		size_t n; \\\n"\
"| 		for ( n = 0; n < max_size && \\\n"\
"| 			     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\\n"\
"| 			buf[n] = (char) c; \\\n"\
"| 		if ( c == '\\n' ) \\\n"\
"| 			buf[n++] = (char) c; \\\n"\
"| 		if ( c == EOF && ferror( yyin ) ) \\\n"\
"| 			YY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n"\
"| 		result = n; \\\n"\
"| 		} \\\n"\
"| 	else \\\n"\
"| 		{ \\\n"\
"| 		errno=0; \\\n"\
"| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\\n"\
"| 			{ \\\n"\
"| 			if( errno != EINTR) \\\n"\
"| 				{ \\\n"\
"| 				YY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n"\
"| 				break; \\\n"\
"| 				} \\\n"\
"| 			errno=0; \\\n"\
"| 			clearerr(yyin); \\\n"\
"| 			} \\\n"\
"| 		}\\\n"\
"| \\\n"\
"| \n"\
"| #endif\n"\
"| \n"\
"| /* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n"\
"|  * we don't want an extra ';' after the \"return\" because that will cause\n"\
"|  * some compilers to complain about unreachable statements.\n"\
"|  */\n"\
"| #ifndef yyterminate\n"\
"| #define yyterminate() return YY_NULL\n"\
"| #endif\n"\
"| \n"\
"| /* Number of entries by which start-condition stack grows. */\n"\
"| #ifndef YY_START_STACK_INCR\n"\
"| #define YY_START_STACK_INCR 25\n"\
"| #endif\n"\
"| \n"\
"| /* Report a fatal error. */\n"\
"| #ifndef YY_FATAL_ERROR\n"\
"| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )\n"\
"| #endif\n"\
"| \n"\
"| /* end tables serialization structures and prototypes */\n"\
"| \n"\
"| /* Default declaration of generated scanner - a define so the user can\n"\
"|  * easily add parameters.\n"\
"|  */\n"\
"| #ifndef YY_DECL\n"\
"| #define YY_DECL_IS_OURS 1\n"\
"| \n"\
"| extern int yylex (void);\n"\
"| \n"\
"| #define YY_DECL int yylex (void)\n"\
"| #endif /* !YY_DECL */\n"\
"| \n"\
"| /* Code executed at the beginning of each rule, after yytext and yyleng\n"\
"|  * have been set up.\n"\
"|  */\n"\
"| #ifndef YY_USER_ACTION\n"\
"| #define YY_USER_ACTION\n"\
"| #endif\n"\
"| \n"\
"| /* Code executed at the end of each rule. */\n"\
"| #ifndef YY_BREAK\n"\
"| #define YY_BREAK break;\n"\
"| #endif\n"\
"| \n"\
"| #define YY_RULE_SETUP \\\n"\
"| 	YY_USER_ACTION\n"\
"| \n"\
"| /** The main scanner function which does all the work.\n"\
"|  */\n"\
"| YY_DECL\n"\
"| {\n"\
"| 	register yy_state_type yy_current_state;\n"\
"| 	register char *yy_cp, *yy_bp;\n"\
"| 	register int yy_act;\n"\
"|     \n"\
"| #line 1 \"conftest.l\"\n"\
"| \n"\
"| #line 666 \"lex.yy.c\"\n"\
"| \n"\
"| 	if ( !(yy_init) )\n"\
"| 		{\n"\
"| 		(yy_init) = 1;\n"\
"| \n"\
"| #ifdef YY_USER_INIT\n"\
"| 		YY_USER_INIT;\n"\
"| #endif\n"\
"| \n"\
"|         /* Create the reject buffer large enough to save one state per allowed character. */\n"\
"|         if ( ! (yy_state_buf) )\n"\
"|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );\n"\
"|             if ( ! (yy_state_buf) )\n"\
"|                 YY_FATAL_ERROR( \"out of dynamic memory in yylex()\" );\n"\
"| \n"\
"| 		if ( ! (yy_start) )\n"\
"| 			(yy_start) = 1;	/* first start state */\n"\
"| \n"\
"| 		if ( ! yyin )\n"\
"| 			yyin = stdin;\n"\
"| \n"\
"| 		if ( ! yyout )\n"\
"| 			yyout = stdout;\n"\
"| \n"\
"| 		if ( ! YY_CURRENT_BUFFER ) {\n"\
"| 			yyensure_buffer_stack ();\n"\
"| 			YY_CURRENT_BUFFER_LVALUE =\n"\
"| 				yy_create_buffer(yyin,YY_BUF_SIZE );\n"\
"| 		}\n"\
"| \n"\
"| 		yy_load_buffer_state( );\n"\
"| 		}\n"\
"| \n"\
"| 	while ( 1 )		/* loops until end-of-file is reached */\n"\
"| 		{\n"\
"| 		(yy_more_len) = 0;\n"\
"| 		if ( (yy_more_flag) )\n"\
"| 			{\n"\
"| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);\n"\
"| 			(yy_more_flag) = 0;\n"\
"| 			}\n"\
"| 		yy_cp = (yy_c_buf_p);\n"\
"| \n"\
"| 		/* Support of yytext. */\n"\
"| 		*yy_cp = (yy_hold_char);\n"\
"| \n"\
"| 		/* yy_bp points to the position in yy_ch_buf of the start of\n"\
"| 		 * the current run.\n"\
"| 		 */\n"\
"| 		yy_bp = yy_cp;\n"\
"| \n"\
"| 		yy_current_state = (yy_start);\n"\
"| \n"\
"| 		(yy_state_ptr) = (yy_state_buf);\n"\
"| 		*(yy_state_ptr)++ = yy_current_state;\n"\
"| \n"\
"| yy_match:\n"\
"| 		do\n"\
"| 			{\n"\
"| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];\n"\
"| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n"\
"| 				{\n"\
"| 				yy_current_state = (int) yy_def[yy_current_state];\n"\
"| 				if ( yy_current_state >= 13 )\n"\
"| 					yy_c = yy_meta[(unsigned int) yy_c];\n"\
"| 				}\n"\
"| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n"\
"| 			*(yy_state_ptr)++ = yy_current_state;\n"\
"| 			++yy_cp;\n"\
"| 			}\n"\
"| 		while ( yy_base[yy_current_state] != 10 );\n"\
"| \n"\
"| yy_find_action:\n"\
"| 		yy_current_state = *--(yy_state_ptr);\n"\
"| 		(yy_lp) = yy_accept[yy_current_state];\n"\
"| find_rule: /* we branch to this label when backing up */\n"\
"| 		for ( ; ; ) /* until we find what rule we matched */\n"\
"| 			{\n"\
"| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )\n"\
"| 				{\n"\
"| 				yy_act = yy_acclist[(yy_lp)];\n"\
"| 					{\n"\
"| 					(yy_full_match) = yy_cp;\n"\
"| 					break;\n"\
"| 					}\n"\
"| 				}\n"\
"| 			--yy_cp;\n"\
"| 			yy_current_state = *--(yy_state_ptr);\n"\
"| 			(yy_lp) = yy_accept[yy_current_state];\n"\
"| 			}\n"\
"| \n"\
"| 		YY_DO_BEFORE_ACTION;\n"\
"| \n"\
"| do_action:	/* This label is used only to access EOF actions. */\n"\
"| \n"\
"| 		switch ( yy_act )\n"\
"| 	{ /* beginning of action switch */\n"\
"| case 1:\n"\
"| YY_RULE_SETUP\n"\
"| #line 2 \"conftest.l\"\n"\
"| { ECHO; }\n"\
"| 	YY_BREAK\n"\
"| case 2:\n"\
"| YY_RULE_SETUP\n"\
"| #line 3 \"conftest.l\"\n"\
"| { REJECT; }\n"\
"| 	YY_BREAK\n"\
"| case 3:\n"\
"| YY_RULE_SETUP\n"\
"| #line 4 \"conftest.l\"\n"\
"| { yymore (); }\n"\
"| 	YY_BREAK\n"\
"| case 4:\n"\
"| YY_RULE_SETUP\n"\
"| #line 5 \"conftest.l\"\n"\
"| { yyless (1); }\n"\
"| 	YY_BREAK\n"\
"| case 5:\n"\
"| YY_RULE_SETUP\n"\
"| #line 6 \"conftest.l\"\n"\
"| { yyless (input () != 0); }\n"\
"| 	YY_BREAK\n"\
"| case 6:\n"\
"| YY_RULE_SETUP\n"\
"| #line 7 \"conftest.l\"\n"\
"| { unput (yytext[0]); }\n"\
"| 	YY_BREAK\n"\
"| case 7:\n"\
"| YY_RULE_SETUP\n"\
"| #line 8 \"conftest.l\"\n"\
"| { BEGIN INITIAL; }\n"\
"| 	YY_BREAK\n"\
"| case 8:\n"\
"| YY_RULE_SETUP\n"\
"| #line 9 \"conftest.l\"\n"\
"| ECHO;\n"\
"| 	YY_BREAK\n"\
"| #line 804 \"lex.yy.c\"\n"\
"| 			case YY_STATE_EOF(INITIAL):\n"\
"| 				yyterminate();\n"\
"| \n"\
"| 	case YY_END_OF_BUFFER:\n"\
"| 		{\n"\
"| 		/* Amount of text matched not including the EOB char. */\n"\
"| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;\n"\
"| \n"\
"| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */\n"\
"| 		*yy_cp = (yy_hold_char);\n"\
"| 		YY_RESTORE_YY_MORE_OFFSET\n"\
"| \n"\
"| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n"\
"| 			{\n"\
"| 			/* We're scanning a new file or input source.  It's\n"\
"| 			 * possible that this happened because the user\n"\
"| 			 * just pointed yyin at a new source and called\n"\
"| 			 * yylex().  If so, then we have to assure\n"\
"| 			 * consistency between YY_CURRENT_BUFFER and our\n"\
"| 			 * globals.  Here is the right place to do so, because\n"\
"| 			 * this is the first action (other than possibly a\n"\
"| 			 * back-up) that will match for the new input source.\n"\
"| 			 */\n"\
"| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n"\
"| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n"\
"| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n"\
"| 			}\n"\
"| \n"\
"| 		/* Note that here we test for yy_c_buf_p \"<=\" to the position\n"\
"| 		 * of the first EOB in the buffer, since yy_c_buf_p will\n"\
"| 		 * already have been incremented past the NUL character\n"\
"| 		 * (since all states make transitions on EOB to the\n"\
"| 		 * end-of-buffer state).  Contrast this with the test\n"\
"| 		 * in input().\n"\
"| 		 */\n"\
"| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n"\
"| 			{ /* This was really a NUL. */\n"\
"| 			yy_state_type yy_next_state;\n"\
"| \n"\
"| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;\n"\
"| \n"\
"| 			yy_current_state = yy_get_previous_state(  );\n"\
"| \n"\
"| 			/* Okay, we're now positioned to make the NUL\n"\
"| 			 * transition.  We couldn't have\n"\
"| 			 * yy_get_previous_state() go ahead and do it\n"\
"| 			 * for us because it doesn't know how to deal\n"\
"| 			 * with the possibility of jamming (and we don't\n"\
"| 			 * want to build jamming into it because then it\n"\
"| 			 * will run more slowly).\n"\
"| 			 */\n"\
"| \n"\
"| 			yy_next_state = yy_try_NUL_trans( yy_current_state );\n"\
"| \n"\
"| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;\n"\
"| \n"\
"| 			if ( yy_next_state )\n"\
"| 				{\n"\
"| 				/* Consume the NUL. */\n"\
"| 				yy_cp = ++(yy_c_buf_p);\n"\
"| 				yy_current_state = yy_next_state;\n"\
"| 				goto yy_match;\n"\
"| 				}\n"\
"| \n"\
"| 			else\n"\
"| 				{\n"\
"| 				yy_cp = (yy_c_buf_p);\n"\
"| 				goto yy_find_action;\n"\
"| 				}\n"\
"| 			}\n"\
"| \n"\
"| 		else switch ( yy_get_next_buffer(  ) )\n"\
"| 			{\n"\
"| 			case EOB_ACT_END_OF_FILE:\n"\
"| 				{\n"\
"| 				(yy_did_buffer_switch_on_eof) = 0;\n"\
"| \n"\
"| 				if ( yywrap( ) )\n"\
"| 					{\n"\
"| 					/* Note: because we've taken care in\n"\
"| 					 * yy_get_next_buffer() to have set up\n"\
"| 					 * yytext, we can now set up\n"\
"| 					 * yy_c_buf_p so that if some total\n"\
"| 					 * hoser (like flex itself) wants to\n"\
"| 					 * call the scanner after we return the\n"\
"| 					 * YY_NULL, it'll still work - another\n"\
"| 					 * YY_NULL will get returned.\n"\
"| 					 */\n"\
"| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;\n"\
"| \n"\
"| 					yy_act = YY_STATE_EOF(YY_START);\n"\
"| 					goto do_action;\n"\
"| 					}\n"\
"| \n"\
"| 				else\n"\
"| 					{\n"\
"| 					if ( ! (yy_did_buffer_switch_on_eof) )\n"\
"| 						YY_NEW_FILE;\n"\
"| 					}\n"\
"| 				break;\n"\
"| 				}\n"\
"| \n"\
"| 			case EOB_ACT_CONTINUE_SCAN:\n"\
"| 				(yy_c_buf_p) =\n"\
"| 					(yytext_ptr) + yy_amount_of_matched_text;\n"\
"| \n"\
"| 				yy_current_state = yy_get_previous_state(  );\n"\
"| \n"\
"| 				yy_cp = (yy_c_buf_p);\n"\
"| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;\n"\
"| 				goto yy_match;\n"\
"| \n"\
"| 			case EOB_ACT_LAST_MATCH:\n"\
"| 				(yy_c_buf_p) =\n"\
"| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];\n"\
"| \n"\
"| 				yy_current_state = yy_get_previous_state(  );\n"\
"| \n"\
"| 				yy_cp = (yy_c_buf_p);\n"\
"| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;\n"\
"| 				goto yy_find_action;\n"\
"| 			}\n"\
"| 		break;\n"\
"| 		}\n"\
"| \n"\
"| 	default:\n"\
"| 		YY_FATAL_ERROR(\n"\
"| 			\"fatal flex scanner internal error--no action found\" );\n"\
"| 	} /* end of action switch */\n"\
"| 		} /* end of scanning one token */\n"\
"| } /* end of yylex */\n"\
"| \n"\
"| /* yy_get_next_buffer - try to read in a new buffer\n"\
"|  *\n"\
"|  * Returns a code representing an action:\n"\
"|  *	EOB_ACT_LAST_MATCH -\n"\
"|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position\n"\
"|  *	EOB_ACT_END_OF_FILE - end of file\n"\
"|  */\n"\
"| static int yy_get_next_buffer (void)\n"\
"| {\n"\
"|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n"\
"| 	register char *source = (yytext_ptr);\n"\
"| 	register int number_to_move, i;\n"\
"| 	int ret_val;\n"\
"| \n"\
"| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n"\
"| 		YY_FATAL_ERROR(\n"\
"| 		\"fatal flex scanner internal error--end of buffer missed\" );\n"\
"| \n"\
"| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n"\
"| 		{ /* Don't try to fill the buffer, so this is an EOF. */\n"\
"| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n"\
"| 			{\n"\
"| 			/* We matched a single character, the EOB, so\n"\
"| 			 * treat this as a final EOF.\n"\
"| 			 */\n"\
"| 			return EOB_ACT_END_OF_FILE;\n"\
"| 			}\n"\
"| \n"\
"| 		else\n"\
"| 			{\n"\
"| 			/* We matched some text prior to the EOB, first\n"\
"| 			 * process it.\n"\
"| 			 */\n"\
"| 			return EOB_ACT_LAST_MATCH;\n"\
"| 			}\n"\
"| 		}\n"\
"| \n"\
"| 	/* Try to read more data. */\n"\
"| \n"\
"| 	/* First move last chars to start of buffer. */\n"\
"| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n"\
"| \n"\
"| 	for ( i = 0; i < number_to_move; ++i )\n"\
"| 		*(dest++) = *(source++);\n"\
"| \n"\
"| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n"\
"| 		/* don't do the read, it's not guaranteed to return an EOF,\n"\
"| 		 * just force an EOF\n"\
"| 		 */\n"\
"| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n"\
"| \n"\
"| 	else\n"\
"| 		{\n"\
"| 			int num_to_read =\n"\
"| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n"\
"| \n"\
"| 		while ( num_to_read <= 0 )\n"\
"| 			{ /* Not enough room in the buffer - grow it. */\n"\
"| \n"\
"| 			YY_FATAL_ERROR(\n"\
"| \"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n"\
"| \n"\
"| 			}\n"\
"| \n"\
"| 		if ( num_to_read > YY_READ_BUF_SIZE )\n"\
"| 			num_to_read = YY_READ_BUF_SIZE;\n"\
"| \n"\
"| 		/* Read in more data. */\n"\
"| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n"\
"| 			(yy_n_chars), (size_t) num_to_read );\n"\
"| \n"\
"| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n"\
"| 		}\n"\
"| \n"\
"| 	if ( (yy_n_chars) == 0 )\n"\
"| 		{\n"\
"| 		if ( number_to_move == YY_MORE_ADJ )\n"\
"| 			{\n"\
"| 			ret_val = EOB_ACT_END_OF_FILE;\n"\
"| 			yyrestart(yyin  );\n"\
"| 			}\n"\
"| \n"\
"| 		else\n"\
"| 			{\n"\
"| 			ret_val = EOB_ACT_LAST_MATCH;\n"\
"| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n"\
"| 				YY_BUFFER_EOF_PENDING;\n"\
"| 			}\n"\
"| 		}\n"\
"| \n"\
"| 	else\n"\
"| 		ret_val = EOB_ACT_CONTINUE_SCAN;\n"\
"| \n"\
"| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n"\
"| 		/* Extend the array by 50%, plus the number we really need. */\n"\
"| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n"\
"| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n"\
"| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n"\
"| 			YY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n"\
"| 	}\n"\
"| \n"\
"| 	(yy_n_chars) += number_to_move;\n"\
"| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n"\
"| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n"\
"| \n"\
"| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n"\
"| \n"\
"| 	return ret_val;\n"\
"| }\n"\
"| \n"\
"| /* yy_get_previous_state - get the state just before the EOB char was reached */\n"\
"| \n"\
"|     static yy_state_type yy_get_previous_state (void)\n"\
"| {\n"\
"| 	register yy_state_type yy_current_state;\n"\
"| 	register char *yy_cp;\n"\
"|     \n"\
"| 	yy_current_state = (yy_start);\n"\
"| \n"\
"| 	(yy_state_ptr) = (yy_state_buf);\n"\
"| 	*(yy_state_ptr)++ = yy_current_state;\n"\
"| \n"\
"| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n"\
"| 		{\n"\
"| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n"\
"| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n"\
"| 			{\n"\
"| 			yy_current_state = (int) yy_def[yy_current_state];\n"\
"| 			if ( yy_current_state >= 13 )\n"\
"| 				yy_c = yy_meta[(unsigned int) yy_c];\n"\
"| 			}\n"\
"| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n"\
"| 		*(yy_state_ptr)++ = yy_current_state;\n"\
"| 		}\n"\
"| \n"\
"| 	return yy_current_state;\n"\
"| }\n"\
"| \n"\
"| /* yy_try_NUL_trans - try to make a transition on the NUL character\n"\
"|  *\n"\
"|  * synopsis\n"\
"|  *	next_state = yy_try_NUL_trans( current_state );\n"\
"|  */\n"\
"|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n"\
"| {\n"\
"| 	register int yy_is_jam;\n"\
"|     \n"\
"| 	register YY_CHAR yy_c = 1;\n"\
"| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n"\
"| 		{\n"\
"| 		yy_current_state = (int) yy_def[yy_current_state];\n"\
"| 		if ( yy_current_state >= 13 )\n"\
"| 			yy_c = yy_meta[(unsigned int) yy_c];\n"\
"| 		}\n"\
"| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n"\
"| 	yy_is_jam = (yy_current_state == 12);\n"\
"| 	if ( ! yy_is_jam )\n"\
"| 		*(yy_state_ptr)++ = yy_current_state;\n"\
"| \n"\
"| 	return yy_is_jam ? 0 : yy_current_state;\n"\
"| }\n"\
"| \n"\
"|     static void yyunput (int c, register char * yy_bp )\n"\
"| {\n"\
"| 	register char *yy_cp;\n"\
"|     \n"\
"|     yy_cp = (yy_c_buf_p);\n"\
"| \n"\
"| 	/* undo effects of setting up yytext */\n"\
"| 	*yy_cp = (yy_hold_char);\n"\
"| \n"\
"| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n"\
"| 		{ /* need to shift things up to make room */\n"\
"| 		/* +2 for EOB chars. */\n"\
"| 		register int number_to_move = (yy_n_chars) + 2;\n"\
"| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n"\
"| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n"\
"| 		register char *source =\n"\
"| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n"\
"| \n"\
"| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n"\
"| 			*--dest = *--source;\n"\
"| \n"\
"| 		yy_cp += (int) (dest - source);\n"\
"| 		yy_bp += (int) (dest - source);\n"\
"| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n"\
"| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n"\
"| \n"\
"| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n"\
"| 			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n"\
"| 		}\n"\
"| \n"\
"| 	*--yy_cp = (char) c;\n"\
"| \n"\
"| 	(yytext_ptr) = yy_bp;\n"\
"| 	(yy_hold_char) = *yy_cp;\n"\
"| 	(yy_c_buf_p) = yy_cp;\n"\
"| }\n"\
"| \n"\
"| #ifndef YY_NO_INPUT\n"\
"| #ifdef __cplusplus\n"\
"|     static int yyinput (void)\n"\
"| #else\n"\
"|     static int input  (void)\n"\
"| #endif\n"\
"| \n"\
"| {\n"\
"| 	int c;\n"\
"|     \n"\
"| 	*(yy_c_buf_p) = (yy_hold_char);\n"\
"| \n"\
"| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n"\
"| 		{\n"\
"| 		/* yy_c_buf_p now points to the character we want to return.\n"\
"| 		 * If this occurs *before* the EOB characters, then it's a\n"\
"| 		 * valid NUL; if not, then we've hit the end of the buffer.\n"\
"| 		 */\n"\
"| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n"\
"| 			/* This was really a NUL. */\n"\
"| 			*(yy_c_buf_p) = '\\0';\n"\
"| \n"\
"| 		else\n"\
"| 			{ /* need more input */\n"\
"| 			int offset = (yy_c_buf_p) - (yytext_ptr);\n"\
"| 			++(yy_c_buf_p);\n"\
"| \n"\
"| 			switch ( yy_get_next_buffer(  ) )\n"\
"| 				{\n"\
"| 				case EOB_ACT_LAST_MATCH:\n"\
"| 					/* This happens because yy_g_n_b()\n"\
"| 					 * sees that we've accumulated a\n"\
"| 					 * token and flags that we need to\n"\
"| 					 * try matching the token before\n"\
"| 					 * proceeding.  But for input(),\n"\
"| 					 * there's no matching to consider.\n"\
"| 					 * So convert the EOB_ACT_LAST_MATCH\n"\
"| 					 * to EOB_ACT_END_OF_FILE.\n"\
"| 					 */\n"\
"| \n"\
"| 					/* Reset buffer status. */\n"\
"| 					yyrestart(yyin );\n"\
"| \n"\
"| 					/*FALLTHROUGH*/\n"\
"| \n"\
"| 				case EOB_ACT_END_OF_FILE:\n"\
"| 					{\n"\
"| 					if ( yywrap( ) )\n"\
"| 						return EOF;\n"\
"| \n"\
"| 					if ( ! (yy_did_buffer_switch_on_eof) )\n"\
"| 						YY_NEW_FILE;\n"\
"| #ifdef __cplusplus\n"\
"| 					return yyinput();\n"\
"| #else\n"\
"| 					return input();\n"\
"| #endif\n"\
"| 					}\n"\
"| \n"\
"| 				case EOB_ACT_CONTINUE_SCAN:\n"\
"| 					(yy_c_buf_p) = (yytext_ptr) + offset;\n"\
"| 					break;\n"\
"| 				}\n"\
"| 			}\n"\
"| 		}\n"\
"| \n"\
"| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */\n"\
"| 	*(yy_c_buf_p) = '\\0';	/* preserve yytext */\n"\
"| 	(yy_hold_char) = *++(yy_c_buf_p);\n"\
"| \n"\
"| 	return c;\n"\
"| }\n"\
"| #endif	/* ifndef YY_NO_INPUT */\n"\
"| \n"\
"| /** Immediately switch to a different input stream.\n"\
"|  * @param input_file A readable stream.\n"\
"|  * \n"\
"|  * @note This function does not reset the start condition to @c INITIAL .\n"\
"|  */\n"\
"|     void yyrestart  (FILE * input_file )\n"\
"| {\n"\
"|     \n"\
"| 	if ( ! YY_CURRENT_BUFFER ){\n"\
"|         yyensure_buffer_stack ();\n"\
"| 		YY_CURRENT_BUFFER_LVALUE =\n"\
"|             yy_create_buffer(yyin,YY_BUF_SIZE );\n"\
"| 	}\n"\
"| \n"\
"| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );\n"\
"| 	yy_load_buffer_state( );\n"\
"| }\n"\
"| \n"\
"| /** Switch to a different input buffer.\n"\
"|  * @param new_buffer The new input buffer.\n"\
"|  * \n"\
"|  */\n"\
"|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n"\
"| {\n"\
"|     \n"\
"| 	/* TODO. We should be able to replace this entire function body\n"\
"| 	 * with\n"\
"| 	 *		yypop_buffer_state();\n"\
"| 	 *		yypush_buffer_state(new_buffer);\n"\
"|      */\n"\
"| 	yyensure_buffer_stack ();\n"\
"| 	if ( YY_CURRENT_BUFFER == new_buffer )\n"\
"| 		return;\n"\
"| \n"\
"| 	if ( YY_CURRENT_BUFFER )\n"\
"| 		{\n"\
"| 		/* Flush out information for old buffer. */\n"\
"| 		*(yy_c_buf_p) = (yy_hold_char);\n"\
"| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n"\
"| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n"\
"| 		}\n"\
"| \n"\
"| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;\n"\
"| 	yy_load_buffer_state( );\n"\
"| \n"\
"| 	/* We don't actually know whether we did this switch during\n"\
"| 	 * EOF (yywrap()) processing, but the only time this flag\n"\
"| 	 * is looked at is after yywrap() is called, so it's safe\n"\
"| 	 * to go ahead and always set it.\n"\
"| 	 */\n"\
"| 	(yy_did_buffer_switch_on_eof) = 1;\n"\
"| }\n"\
"| \n"\
"| static void yy_load_buffer_state  (void)\n"\
"| {\n"\
"|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n"\
"| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n"\
"| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n"\
"| 	(yy_hold_char) = *(yy_c_buf_p);\n"\
"| }\n"\
"| \n"\
"| /** Allocate and initialize an input buffer state.\n"\
"|  * @param file A readable stream.\n"\
"|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n"\
"|  * \n"\
"|  * @return the allocated buffer state.\n"\
"|  */\n"\
"|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n"\
"| {\n"\
"| 	YY_BUFFER_STATE b;\n"\
"|     \n"\
"| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n"\
"| 	if ( ! b )\n"\
"| 		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n"\
"| \n"\
"| 	b->yy_buf_size = size;\n"\
"| \n"\
"| 	/* yy_ch_buf has to be 2 characters longer than the size given because\n"\
"| 	 * we need to put in 2 end-of-buffer characters.\n"\
"| 	 */\n"\
"| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );\n"\
"| 	if ( ! b->yy_ch_buf )\n"\
"| 		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n"\
"| \n"\
"| 	b->yy_is_our_buffer = 1;\n"\
"| \n"\
"| 	yy_init_buffer(b,file );\n"\
"| \n"\
"| 	return b;\n"\
"| }\n"\
"| \n"\
"| /** Destroy the buffer.\n"\
"|  * @param b a buffer created with yy_create_buffer()\n"\
"|  * \n"\
"|  */\n"\
"|     void yy_delete_buffer (YY_BUFFER_STATE  b )\n"\
"| {\n"\
"|     \n"\
"| 	if ( ! b )\n"\
"| 		return;\n"\
"| \n"\
"| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n"\
"| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n"\
"| \n"\
"| 	if ( b->yy_is_our_buffer )\n"\
"| 		yyfree((void *) b->yy_ch_buf  );\n"\
"| \n"\
"| 	yyfree((void *) b  );\n"\
"| }\n"\
"| \n"\
"| #ifndef __cplusplus\n"\
"| extern int isatty (int );\n"\
"| #endif /* __cplusplus */\n"\
"|     \n"\
"| /* Initializes or reinitializes a buffer.\n"\
"|  * This function is sometimes called more than once on the same buffer,\n"\
"|  * such as during a yyrestart() or at EOF.\n"\
"|  */\n"\
"|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n"\
"| \n"\
"| {\n"\
"| 	int oerrno = errno;\n"\
"|     \n"\
"| 	yy_flush_buffer(b );\n"\
"| \n"\
"| 	b->yy_input_file = file;\n"\
"| 	b->yy_fill_buffer = 1;\n"\
"| \n"\
"|     /* If b is the current buffer, then yy_init_buffer was _probably_\n"\
"|      * called from yyrestart() or through yy_get_next_buffer.\n"\
"|      * In that case, we don't want to reset the lineno or column.\n"\
"|      */\n"\
"|     if (b != YY_CURRENT_BUFFER){\n"\
"|         b->yy_bs_lineno = 1;\n"\
"|         b->yy_bs_column = 0;\n"\
"|     }\n"\
"| \n"\
"|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n"\
"|     \n"\
"| 	errno = oerrno;\n"\
"| }\n"\
"| \n"\
"| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n"\
"|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n"\
"|  * \n"\
"|  */\n"\
"|     void yy_flush_buffer (YY_BUFFER_STATE  b )\n"\
"| {\n"\
"|     	if ( ! b )\n"\
"| 		return;\n"\
"| \n"\
"| 	b->yy_n_chars = 0;\n"\
"| \n"\
"| 	/* We always need two end-of-buffer characters.  The first causes\n"\
"| 	 * a transition to the end-of-buffer state.  The second causes\n"\
"| 	 * a jam in that state.\n"\
"| 	 */\n"\
"| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n"\
"| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n"\
"| \n"\
"| 	b->yy_buf_pos = &b->yy_ch_buf[0];\n"\
"| \n"\
"| 	b->yy_at_bol = 1;\n"\
"| 	b->yy_buffer_status = YY_BUFFER_NEW;\n"\
"| \n"\
"| 	if ( b == YY_CURRENT_BUFFER )\n"\
"| 		yy_load_buffer_state( );\n"\
"| }\n"\
"| \n"\
"| /** Pushes the new state onto the stack. The new state becomes\n"\
"|  *  the current state. This function will allocate the stack\n"\
"|  *  if necessary.\n"\
"|  *  @param new_buffer The new state.\n"\
"|  *  \n"\
"|  */\n"\
"| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n"\
"| {\n"\
"|     	if (new_buffer == NULL)\n"\
"| 		return;\n"\
"| \n"\
"| 	yyensure_buffer_stack();\n"\
"| \n"\
"| 	/* This block is copied from yy_switch_to_buffer. */\n"\
"| 	if ( YY_CURRENT_BUFFER )\n"\
"| 		{\n"\
"| 		/* Flush out information for old buffer. */\n"\
"| 		*(yy_c_buf_p) = (yy_hold_char);\n"\
"| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n"\
"| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n"\
"| 		}\n"\
"| \n"\
"| 	/* Only push if top exists. Otherwise, replace top. */\n"\
"| 	if (YY_CURRENT_BUFFER)\n"\
"| 		(yy_buffer_stack_top)++;\n"\
"| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;\n"\
"| \n"\
"| 	/* copied from yy_switch_to_buffer. */\n"\
"| 	yy_load_buffer_state( );\n"\
"| 	(yy_did_buffer_switch_on_eof) = 1;\n"\
"| }\n"\
"| \n"\
"| /** Removes and deletes the top of the stack, if present.\n"\
"|  *  The next element becomes the new top.\n"\
"|  *  \n"\
"|  */\n"\
"| void yypop_buffer_state (void)\n"\
"| {\n"\
"|     	if (!YY_CURRENT_BUFFER)\n"\
"| 		return;\n"\
"| \n"\
"| 	yy_delete_buffer(YY_CURRENT_BUFFER );\n"\
"| 	YY_CURRENT_BUFFER_LVALUE = NULL;\n"\
"| 	if ((yy_buffer_stack_top) > 0)\n"\
"| 		--(yy_buffer_stack_top);\n"\
"| \n"\
"| 	if (YY_CURRENT_BUFFER) {\n"\
"| 		yy_load_buffer_state( );\n"\
"| 		(yy_did_buffer_switch_on_eof) = 1;\n"\
"| 	}\n"\
"| }\n"\
"| \n"\
"| /* Allocates the stack if it does not exist.\n"\
"|  *  Guarantees space for at least one push.\n"\
"|  */\n"\
"| static void yyensure_buffer_stack (void)\n"\
"| {\n"\
"| 	int num_to_alloc;\n"\
"|     \n"\
"| 	if (!(yy_buffer_stack)) {\n"\
"| \n"\
"| 		/* First allocation is just for 2 elements, since we don't know if this\n"\
"| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an\n"\
"| 		 * immediate realloc on the next call.\n"\
"|          */\n"\
"| 		num_to_alloc = 1;\n"\
"| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n"\
"| 								(num_to_alloc * sizeof(struct yy_buffer_state*)\n"\
"| 								);\n"\
"| 		if ( ! (yy_buffer_stack) )\n"\
"| 			YY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n"\
"| 								  \n"\
"| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n"\
"| 				\n"\
"| 		(yy_buffer_stack_max) = num_to_alloc;\n"\
"| 		(yy_buffer_stack_top) = 0;\n"\
"| 		return;\n"\
"| 	}\n"\
"| \n"\
"| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n"\
"| \n"\
"| 		/* Increase the buffer to prepare for a possible push. */\n"\
"| 		int grow_size = 8 /* arbitrary grow size */;\n"\
"| \n"\
"| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;\n"\
"| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n"\
"| 								((yy_buffer_stack),\n"\
"| 								num_to_alloc * sizeof(struct yy_buffer_state*)\n"\
"| 								);\n"\
"| 		if ( ! (yy_buffer_stack) )\n"\
"| 			YY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n"\
"| \n"\
"| 		/* zero only the new slots.*/\n"\
"| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n"\
"| 		(yy_buffer_stack_max) = num_to_alloc;\n"\
"| 	}\n"\
"| }\n"\
"| \n"\
"| /** Setup the input buffer state to scan directly from a user-specified character buffer.\n"\
"|  * @param base the character buffer\n"\
"|  * @param size the size in bytes of the character buffer\n"\
"|  * \n"\
"|  * @return the newly allocated buffer state object. \n"\
"|  */\n"\
"| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n"\
"| {\n"\
"| 	YY_BUFFER_STATE b;\n"\
"|     \n"\
"| 	if ( size < 2 ||\n"\
"| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n"\
"| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )\n"\
"| 		/* They forgot to leave room for the EOB's. */\n"\
"| 		return 0;\n"\
"| \n"\
"| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n"\
"| 	if ( ! b )\n"\
"| 		YY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n"\
"| \n"\
"| 	b->yy_buf_size = size - 2;	/* \"- 2\" to take care of EOB's */\n"\
"| 	b->yy_buf_pos = b->yy_ch_buf = base;\n"\
"| 	b->yy_is_our_buffer = 0;\n"\
"| 	b->yy_input_file = 0;\n"\
"| 	b->yy_n_chars = b->yy_buf_size;\n"\
"| 	b->yy_is_interactive = 0;\n"\
"| 	b->yy_at_bol = 1;\n"\
"| 	b->yy_fill_buffer = 0;\n"\
"| 	b->yy_buffer_status = YY_BUFFER_NEW;\n"\
"| \n"\
"| 	yy_switch_to_buffer(b  );\n"\
"| \n"\
"| 	return b;\n"\
"| }\n"\
"| \n"\
"| /** Setup the input buffer state to scan a string. The next call to yylex() will\n"\
"|  * scan from a @e copy of @a str.\n"\
"|  * @param yystr a NUL-terminated string to scan\n"\
"|  * \n"\
"|  * @return the newly allocated buffer state object.\n"\
"|  * @note If you want to scan bytes that may contain NUL values, then use\n"\
"|  *       yy_scan_bytes() instead.\n"\
"|  */\n"\
"| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )\n"\
"| {\n"\
"|     \n"\
"| 	return yy_scan_bytes(yystr,strlen(yystr) );\n"\
"| }\n"\
"| \n"\
"| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n"\
"|  * scan from a @e copy of @a bytes.\n"\
"|  * @param yybytes the byte buffer to scan\n"\
"|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n"\
"|  * \n"\
"|  * @return the newly allocated buffer state object.\n"\
"|  */\n"\
"| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n"\
"| {\n"\
"| 	YY_BUFFER_STATE b;\n"\
"| 	char *buf;\n"\
"| 	yy_size_t n;\n"\
"| 	int i;\n"\
"|     \n"\
"| 	/* Get memory for full buffer, including space for trailing EOB's. */\n"\
"| 	n = _yybytes_len + 2;\n"\
"| 	buf = (char *) yyalloc(n  );\n"\
"| 	if ( ! buf )\n"\
"| 		YY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n"\
"| \n"\
"| 	for ( i = 0; i < _yybytes_len; ++i )\n"\
"| 		buf[i] = yybytes[i];\n"\
"| \n"\
"| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n"\
"| \n"\
"| 	b = yy_scan_buffer(buf,n );\n"\
"| 	if ( ! b )\n"\
"| 		YY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n"\
"| \n"\
"| 	/* It's okay to grow etc. this buffer, and we should throw it\n"\
"| 	 * away when we're done.\n"\
"| 	 */\n"\
"| 	b->yy_is_our_buffer = 1;\n"\
"| \n"\
"| 	return b;\n"\
"| }\n"\
"| \n"\
"| #ifndef YY_EXIT_FAILURE\n"\
"| #define YY_EXIT_FAILURE 2\n"\
"| #endif\n"\
"| \n"\
"| static void yy_fatal_error (yyconst char* msg )\n"\
"| {\n"\
"|     	(void) fprintf( stderr, \"%s\\n\", msg );\n"\
"| 	exit( YY_EXIT_FAILURE );\n"\
"| }\n"\
"| \n"\
"| /* Redefine yyless() so it works in section 3 code. */\n"\
"| \n"\
"| #undef yyless\n"\
"| #define yyless(n) \\\n"\
"| 	do \\\n"\
"| 		{ \\\n"\
"| 		/* Undo effects of setting up yytext. */ \\\n"\
"|         int yyless_macro_arg = (n); \\\n"\
"|         YY_LESS_LINENO(yyless_macro_arg);\\\n"\
"| 		yytext[yyleng] = (yy_hold_char); \\\n"\
"| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \\\n"\
"| 		(yy_hold_char) = *(yy_c_buf_p); \\\n"\
"| 		*(yy_c_buf_p) = '\\0'; \\\n"\
"| 		yyleng = yyless_macro_arg; \\\n"\
"| 		} \\\n"\
"| 	while ( 0 )\n"\
"| \n"\
"| /* Accessor  methods (get/set functions) to struct members. */\n"\
"| \n"\
"| /** Get the current line number.\n"\
"|  * \n"\
"|  */\n"\
"| int yyget_lineno  (void)\n"\
"| {\n"\
"|         \n"\
"|     return yylineno;\n"\
"| }\n"\
"| \n"\
"| /** Get the input stream.\n"\
"|  * \n"\
"|  */\n"\
"| FILE *yyget_in  (void)\n"\
"| {\n"\
"|         return yyin;\n"\
"| }\n"\
"| \n"\
"| /** Get the output stream.\n"\
"|  * \n"\
"|  */\n"\
"| FILE *yyget_out  (void)\n"\
"| {\n"\
"|         return yyout;\n"\
"| }\n"\
"| \n"\
"| /** Get the length of the current token.\n"\
"|  * \n"\
"|  */\n"\
"| int yyget_leng  (void)\n"\
"| {\n"\
"|         return yyleng;\n"\
"| }\n"\
"| \n"\
"| /** Get the current token.\n"\
"|  * \n"\
"|  */\n"\
"| \n"\
"| char *yyget_text  (void)\n"\
"| {\n"\
"|         return yytext;\n"\
"| }\n"\
"| \n"\
"| /** Set the current line number.\n"\
"|  * @param line_number\n"\
"|  * \n"\
"|  */\n"\
"| void yyset_lineno (int  line_number )\n"\
"| {\n"\
"|     \n"\
"|     yylineno = line_number;\n"\
"| }\n"\
"| \n"\
"| /** Set the input stream. This does not discard the current\n"\
"|  * input buffer.\n"\
"|  * @param in_str A readable stream.\n"\
"|  * \n"\
"|  * @see yy_switch_to_buffer\n"\
"|  */\n"\
"| void yyset_in (FILE *  in_str )\n"\
"| {\n"\
"|         yyin = in_str ;\n"\
"| }\n"\
"| \n"\
"| void yyset_out (FILE *  out_str )\n"\
"| {\n"\
"|         yyout = out_str ;\n"\
"| }\n"\
"| \n"\
"| int yyget_debug  (void)\n"\
"| {\n"\
"|         return yy_flex_debug;\n"\
"| }\n"\
"| \n"\
"| void yyset_debug (int  bdebug )\n"\
"| {\n"\
"|         yy_flex_debug = bdebug ;\n"\
"| }\n"\
"| \n"\
"| static int yy_init_globals (void)\n"\
"| {\n"\
"|         /* Initialization is the same as for the non-reentrant scanner.\n"\
"|      * This function is called from yylex_destroy(), so don't allocate here.\n"\
"|      */\n"\
"| \n"\
"|     (yy_buffer_stack) = 0;\n"\
"|     (yy_buffer_stack_top) = 0;\n"\
"|     (yy_buffer_stack_max) = 0;\n"\
"|     (yy_c_buf_p) = (char *) 0;\n"\
"|     (yy_init) = 0;\n"\
"|     (yy_start) = 0;\n"\
"| \n"\
"|     (yy_state_buf) = 0;\n"\
"|     (yy_state_ptr) = 0;\n"\
"|     (yy_full_match) = 0;\n"\
"|     (yy_lp) = 0;\n"\
"| \n"\
"| /* Defined in main.c */\n"\
"| #ifdef YY_STDINIT\n"\
"|     yyin = stdin;\n"\
"|     yyout = stdout;\n"\
"| #else\n"\
"|     yyin = (FILE *) 0;\n"\
"|     yyout = (FILE *) 0;\n"\
"| #endif\n"\
"| \n"\
"|     /* For future reference: Set errno on error, since we are called by\n"\
"|      * yylex_init()\n"\
"|      */\n"\
"|     return 0;\n"\
"| }\n"\
"| \n"\
"| /* yylex_destroy is for both reentrant and non-reentrant scanners. */\n"\
"| int yylex_destroy  (void)\n"\
"| {\n"\
"|     \n"\
"|     /* Pop the buffer stack, destroying each element. */\n"\
"| 	while(YY_CURRENT_BUFFER){\n"\
"| 		yy_delete_buffer(YY_CURRENT_BUFFER  );\n"\
"| 		YY_CURRENT_BUFFER_LVALUE = NULL;\n"\
"| 		yypop_buffer_state();\n"\
"| 	}\n"\
"| \n"\
"| 	/* Destroy the stack itself. */\n"\
"| 	yyfree((yy_buffer_stack) );\n"\
"| 	(yy_buffer_stack) = NULL;\n"\
"| \n"\
"|     yyfree ( (yy_state_buf) );\n"\
"|     (yy_state_buf)  = NULL;\n"\
"| \n"\
"|     /* Reset the globals. This is important in a non-reentrant scanner so the next time\n"\
"|      * yylex() is called, initialization will occur. */\n"\
"|     yy_init_globals( );\n"\
"| \n"\
"|     return 0;\n"\
"| }\n"\
"| \n"\
"| /*\n"\
"|  * Internal utility routines.\n"\
"|  */\n"\
"| \n"\
"| #ifndef yytext_ptr\n"\
"| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n"\
"| {\n"\
"| 	register int i;\n"\
"| 	for ( i = 0; i < n; ++i )\n"\
"| 		s1[i] = s2[i];\n"\
"| }\n"\
"| #endif\n"\
"| \n"\
"| #ifdef YY_NEED_STRLEN\n"\
"| static int yy_flex_strlen (yyconst char * s )\n"\
"| {\n"\
"| 	register int n;\n"\
"| 	for ( n = 0; s[n]; ++n )\n"\
"| 		;\n"\
"| \n"\
"| 	return n;\n"\
"| }\n"\
"| #endif\n"\
"| \n"\
"| void *yyalloc (yy_size_t  size )\n"\
"| {\n"\
"| 	return (void *) malloc( size );\n"\
"| }\n"\
"| \n"\
"| void *yyrealloc  (void * ptr, yy_size_t  size )\n"\
"| {\n"\
"| 	/* The cast to (char *) in the following accommodates both\n"\
"| 	 * implementations that use char* generic pointers, and those\n"\
"| 	 * that use void* generic pointers.  It works with the latter\n"\
"| 	 * because both ANSI C and C++ allow castless assignment from\n"\
"| 	 * any pointer type to void*, and deal with argument conversions\n"\
"| 	 * as though doing an assignment.\n"\
"| 	 */\n"\
"| 	return (void *) realloc( (char *) ptr, size );\n"\
"| }\n"\
"| \n"\
"| void yyfree (void * ptr )\n"\
"| {\n"\
"| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */\n"\
"| }\n"\
"| \n"\
"| #define YYTABLES_NAME \"yytables\"\n"\
"| \n"\
"| #line 9 \"conftest.l\"\n"\
"| \n"\
"| \n"\
"| #ifdef YYTEXT_POINTER\n"\
"| extern char *yytext;\n"\
"| #endif\n"\
"| int\n"\
"| main (void)\n"\
"| {\n"\
"|   return ! yylex () + ! yywrap ();\n"\
"| }\n"\
"configure:4089: gcc -o conftest -g -O2   conftest.c -lfl  >&5\n"\
"configure:4089: $? = 0\n"\
"configure:4099: result: -lfl\n"\
"configure:4105: checking whether yytext is a pointer\n"\
"configure:4121: gcc -o conftest -g -O2   conftest.c -lfl  >&5\n"\
"configure:4121: $? = 0\n"\
"configure:4129: result: yes\n"\
"configure:4143: checking for bison\n"\
"configure:4159: found /usr/bin/bison\n"\
"configure:4170: result: bison -y\n"\
"configure:4188: checking build system type\n"\
"configure:4202: result: x86_64-unknown-linux-gnu\n"\
"configure:4223: checking whether to enable assertions\n"\
"configure:4241: result: yes\n"\
"configure:4264: checking for a sed that does not truncate output\n"\
"configure:4328: result: /bin/sed\n"\
"configure:4333: checking for grep that handles long lines and -e\n"\
"configure:4391: result: /bin/grep\n"\
"configure:4400: checking for gawk\n"\
"configure:4427: result: gawk\n"\
"configure:4489: checking for mktemp\n"\
"configure:4489: gcc -o conftest -g -O2   conftest.c  >&5\n"\
"/tmp/ccdjLuTX.o: In function `main':\n"\
"/home/jeed/workspace/safira/conftest.c:50: warning: the use of `mktemp' is dangerous, better use `mkstemp' or `mkdtemp'\n"\
"configure:4489: $? = 0\n"\
"configure:4489: result: yes\n"\
"configure:4489: checking for vfprintf\n"\
"configure:4489: gcc -o conftest -g -O2   conftest.c  >&5\n"\
"conftest.c:40: warning: conflicting types for built-in function 'vfprintf'\n"\
"configure:4489: $? = 0\n"\
"configure:4489: result: yes\n"\
"configure:4505: checking whether ln -s works\n"\
"configure:4509: result: yes\n"\
"configure:4559: checking for ranlib\n"\
"configure:4575: found /usr/bin/ranlib\n"\
"configure:4586: result: ranlib\n"\
"configure:4611: checking for dot\n"\
"configure:4629: found /usr/bin/dot\n"\
"configure:4642: result: /usr/bin/dot\n"\
"configure:4793: creating ./config.status\n"\
"\n"\
"## ---------------------- ##\n"\
"## Running config.status. ##\n"\
"## ---------------------- ##\n"\
"\n"\
"This file was extended by Safira config.status 2.0, which was\n"\
"generated by GNU Autoconf 2.65.  Invocation command line was\n"\
"\n"\
"  CONFIG_FILES    = \n"\
"  CONFIG_HEADERS  = \n"\
"  CONFIG_LINKS    = \n"\
"  CONFIG_COMMANDS = \n"\
"  $ ./config.status \n"\
"\n"\
"on SomTam\n"\
"\n"\
"config.status:882: creating Makefile\n"\
"config.status:882: creating src/Makefile\n"\
"config.status:882: creating libs/minisat/Makefile\n"\
"config.status:882: creating tests/Makefile\n"\
"config.status:882: creating tests/package.m4\n"\
"config.status:882: creating man/Makefile\n"\
"config.status:882: creating doc/Makefile\n"\
"config.status:882: creating doc/Doxyfile\n"\
"config.status:882: creating tests/cover.sh\n"\
"config.status:882: creating src/config.h\n"\
"config.status:1054: src/config.h is unchanged\n"\
"config.status:1102: executing depfiles commands\n"\
"config.status:1102: executing tests/atconfig commands\n"\
"\n"\
"## ---------------- ##\n"\
"## Cache variables. ##\n"\
"## ---------------- ##\n"\
"\n"\
"ac_cv_build=x86_64-unknown-linux-gnu\n"\
"ac_cv_c_compiler_gnu=yes\n"\
"ac_cv_cxx_compiler_gnu=yes\n"\
"ac_cv_env_CCC_set=\n"\
"ac_cv_env_CCC_value=\n"\
"ac_cv_env_CC_set=\n"\
"ac_cv_env_CC_value=\n"\
"ac_cv_env_CFLAGS_set=\n"\
"ac_cv_env_CFLAGS_value=\n"\
"ac_cv_env_CPPFLAGS_set=\n"\
"ac_cv_env_CPPFLAGS_value=\n"\
"ac_cv_env_CXXFLAGS_set=\n"\
"ac_cv_env_CXXFLAGS_value=\n"\
"ac_cv_env_CXX_set=\n"\
"ac_cv_env_CXX_value=\n"\
"ac_cv_env_LDFLAGS_set=\n"\
"ac_cv_env_LDFLAGS_value=\n"\
"ac_cv_env_LIBS_set=\n"\
"ac_cv_env_LIBS_value=\n"\
"ac_cv_env_YACC_set=\n"\
"ac_cv_env_YACC_value=\n"\
"ac_cv_env_YFLAGS_set=\n"\
"ac_cv_env_YFLAGS_value=\n"\
"ac_cv_env_build_alias_set=\n"\
"ac_cv_env_build_alias_value=\n"\
"ac_cv_env_host_alias_set=\n"\
"ac_cv_env_host_alias_value=\n"\
"ac_cv_env_target_alias_set=\n"\
"ac_cv_env_target_alias_value=\n"\
"ac_cv_func_mktemp=yes\n"\
"ac_cv_func_vfprintf=yes\n"\
"ac_cv_lib_lex=-lfl\n"\
"ac_cv_objext=o\n"\
"ac_cv_path_DOT=/usr/bin/dot\n"\
"ac_cv_path_GREP=/bin/grep\n"\
"ac_cv_path_SED=/bin/sed\n"\
"ac_cv_path_install='/usr/bin/install -c'\n"\
"ac_cv_path_mkdir=/bin/mkdir\n"\
"ac_cv_prog_AWK=gawk\n"\
"ac_cv_prog_LEX=flex\n"\
"ac_cv_prog_YACC='bison -y'\n"\
"ac_cv_prog_ac_ct_CC=gcc\n"\
"ac_cv_prog_ac_ct_CXX=g++\n"\
"ac_cv_prog_ac_ct_RANLIB=ranlib\n"\
"ac_cv_prog_cc_c89=\n"\
"ac_cv_prog_cc_g=yes\n"\
"ac_cv_prog_cc_gcc_c_o=yes\n"\
"ac_cv_prog_cxx_g=yes\n"\
"ac_cv_prog_lex_root=lex.yy\n"\
"ac_cv_prog_lex_yytext_pointer=yes\n"\
"ac_cv_prog_make_make_set=yes\n"\
"am_cv_CC_dependencies_compiler_type=gcc3\n"\
"am_cv_CXX_dependencies_compiler_type=gcc3\n"\
"\n"\
"## ----------------- ##\n"\
"## Output variables. ##\n"\
"## ----------------- ##\n"\
"\n"\
"ACLOCAL='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run aclocal-1.11'\n"\
"AMDEPBACKSLASH='\\'\n"\
"AMDEP_FALSE='#'\n"\
"AMDEP_TRUE=''\n"\
"AMTAR='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run tar'\n"\
"AM_BACKSLASH='\\'\n"\
"AM_DEFAULT_VERBOSITY='0'\n"\
"AUTOCONF='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run autoconf'\n"\
"AUTOHEADER='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run autoheader'\n"\
"AUTOM4TE='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run autom4te'\n"\
"AUTOMAKE='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run automake-1.11'\n"\
"AWK='gawk'\n"\
"CC='gcc'\n"\
"CCDEPMODE='depmode=gcc3'\n"\
"CFLAGS='-g -O2'\n"\
"CPPFLAGS=''\n"\
"CXX='g++'\n"\
"CXXDEPMODE='depmode=gcc3'\n"\
"CXXFLAGS='-g -O2'\n"\
"CYGPATH_W='echo'\n"\
"DEFS='-DHAVE_CONFIG_H'\n"\
"DEPDIR='.deps'\n"\
"DOT='/usr/bin/dot'\n"\
"ECHO_C=''\n"\
"ECHO_N='-n'\n"\
"ECHO_T=''\n"\
"EXEEXT=''\n"\
"GENGETOPT='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run gengetopt'\n"\
"GREP='/bin/grep'\n"\
"HELP2MAN='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run help2man'\n"\
"INSTALL_DATA='${INSTALL} -m 644'\n"\
"INSTALL_PROGRAM='${INSTALL}'\n"\
"INSTALL_SCRIPT='${INSTALL}'\n"\
"INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'\n"\
"LDFLAGS=''\n"\
"LEX='flex'\n"\
"LEXLIB='-lfl'\n"\
"LEX_OUTPUT_ROOT='lex.yy'\n"\
"LIBOBJS=''\n"\
"LIBS=''\n"\
"LN_S='ln -s'\n"\
"LTLIBOBJS=''\n"\
"MAKEINFO='${SHELL} /home/jeed/workspace/safira/build-aux/missing --run makeinfo'\n"\
"MKDIR_P='/bin/mkdir -p'\n"\
"OBJEXT='o'\n"\
"PACKAGE='safira'\n"\
"PACKAGE_BUGREPORT='safira@service-technology.org'\n"\
"PACKAGE_NAME='Safira'\n"\
"PACKAGE_STRING='Safira 2.0'\n"\
"PACKAGE_TARNAME='safira'\n"\
"PACKAGE_URL='http://service-technology.org/safira'\n"\
"PACKAGE_VERSION='2.0'\n"\
"PATH_SEPARATOR=':'\n"\
"RANLIB='ranlib'\n"\
"SED='/bin/sed'\n"\
"SET_MAKE=''\n"\
"SHELL='/bin/bash'\n"\
"STRIP=''\n"\
"VERSION='2.0'\n"\
"VERSION_SVN='5755'\n"\
"YACC='bison -y'\n"\
"YFLAGS=''\n"\
"ac_ct_CC='gcc'\n"\
"ac_ct_CXX='g++'\n"\
"am__EXEEXT_FALSE=''\n"\
"am__EXEEXT_TRUE='#'\n"\
"am__fastdepCC_FALSE='#'\n"\
"am__fastdepCC_TRUE=''\n"\
"am__fastdepCXX_FALSE='#'\n"\
"am__fastdepCXX_TRUE=''\n"\
"am__include='include'\n"\
"am__isrc=''\n"\
"am__leading_dot='.'\n"\
"am__quote=''\n"\
"am__tar='${AMTAR} chof - \"$$tardir\"'\n"\
"am__untar='${AMTAR} xf -'\n"\
"bindir='${exec_prefix}/bin'\n"\
"build='x86_64-unknown-linux-gnu'\n"\
"build_alias=''\n"\
"build_cpu='x86_64'\n"\
"build_os='linux-gnu'\n"\
"build_vendor='unknown'\n"\
"datadir='${datarootdir}'\n"\
"datarootdir='${prefix}/share'\n"\
"docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'\n"\
"dvidir='${docdir}'\n"\
"exec_prefix='${prefix}'\n"\
"host_alias=''\n"\
"htmldir='${docdir}'\n"\
"includedir='${prefix}/include'\n"\
"infodir='${datarootdir}/info'\n"\
"install_sh='${SHELL} /home/jeed/workspace/safira/build-aux/install-sh'\n"\
"libdir='${exec_prefix}/lib'\n"\
"libexecdir='${exec_prefix}/libexec'\n"\
"localedir='${datarootdir}/locale'\n"\
"localstatedir='${prefix}/var'\n"\
"mandir='${datarootdir}/man'\n"\
"mkdir_p='/bin/mkdir -p'\n"\
"oldincludedir='/usr/include'\n"\
"pdfdir='${docdir}'\n"\
"prefix='/usr/local'\n"\
"program_transform_name='s,x,x,'\n"\
"psdir='${docdir}'\n"\
"sbindir='${exec_prefix}/sbin'\n"\
"sharedstatedir='${prefix}/com'\n"\
"sysconfdir='${prefix}/etc'\n"\
"target_alias=''\n"\
"\n"\
"## ----------- ##\n"\
"## confdefs.h. ##\n"\
"## ----------- ##\n"\
"\n"\
"/* confdefs.h */\n"\
"#define PACKAGE_NAME \"Safira\"\n"\
"#define PACKAGE_TARNAME \"safira\"\n"\
"#define PACKAGE_VERSION \"2.0\"\n"\
"#define PACKAGE_STRING \"Safira 2.0\"\n"\
"#define PACKAGE_BUGREPORT \"safira@service-technology.org\"\n"\
"#define PACKAGE_URL \"http://service-technology.org/safira\"\n"\
"#define PACKAGE \"safira\"\n"\
"#define VERSION \"2.0\"\n"\
"#define YYTEXT_POINTER 1\n"\
"#define VERSION_SVN \"5755\"\n"\
"#define CONFIG_BUILDSYSTEM \"x86_64-unknown-linux-gnu\"\n"\
"#define TOOL_AWK \"\\\"gawk\\\"\"\n"\
"#define TOOL_GREP \"\\\"/bin/grep\\\"\"\n"\
"#define HAVE_MKTEMP 1\n"\
"#define HAVE_VFPRINTF 1\n"\
"#define CONFIG_DOT \"/usr/bin/dot\"\n"\
"\n"\
"configure: exit 0\n"\
""

