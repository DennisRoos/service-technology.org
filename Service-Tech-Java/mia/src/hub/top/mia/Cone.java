package hub.top.mia;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Stack;
import java.util.Vector;

public class Cone {
	/** set with all elements of the cone **/
	private Vector<Marking> cone;
	private Marking source;
	
	/** necessary for computing TSCCs**/
	private Stack<Marking> stack;
	
	public Cone() {
		cone = new Vector<Marking>();
	}
	
	public Cone(Marking source) {
		this();
		this.source = source;
	}
	
	public void addMarking(Marking element) {
		cone.add(element);
	}
	
	public void removeMarking(Marking element) {
		cone.remove(element);
	}
	
	public Marking getElement(Marking element) {
		int index = cone.indexOf(element);
		if (index == -1) {
			return null;
		}
		
		return cone.get(index);
	}
	
	/**
	 * compute cone from given source
	 * @param source
	 * @param subcone
	 * @return
	 */
	public boolean generateCone(HashSet<Marking> subcone) {
		// start from current marking, recursively generate successors until
		// nothing new is added
		// initially add this to cone

		boolean expanded = false;
		cone.add(source);
		source.setCone(this);
		
		// check if current node is part of cone
		for (Marking element : subcone) {
			if (element.equals(source)) {
				element.setHasCone(true);
			}
		}
		
		// set with intermediate successors
		HashSet<Marking> successors = new HashSet<Marking>();
		
		// set with newly generated successors
		ArrayList<Marking> currentSuccessors = new ArrayList<Marking>();
		currentSuccessors.add(source);
		
		ArrayList<Marking> newSuccessors = new ArrayList<Marking>();
		do {
			expanded  = false;
			newSuccessors.clear();
			
			for (Marking node : currentSuccessors) {
				node.generateSuccessors();
				
				// feed intermediate successors set with all forward and backward successors of node successor 
				successors.clear();
				successors.addAll(node.getForwardSuccessor());
				successors.addAll(node.getBackSuccesors());
				
				for (Marking newSuccessor : successors) {
					// add element to cone if it is not in cone and not generated previously
					if (!isInCone(newSuccessor) && !newSuccessors.contains(newSuccessor)) {
						// check if some element of the sub-cone is equal to successor
						for (Marking element : subcone) {
							if (element.equals(newSuccessor)) {
								element.setHasCone(true);
							}
						}
						
						// add successor to newly generated successors list
						newSuccessors.add(newSuccessor);
						
						// set expanded to true
						expanded = true;
					}
				}
			}
			
			// add new elements
			cone.addAll(newSuccessors);
			
			// add current successors to the list for the next iteration
			currentSuccessors.clear();
			currentSuccessors.addAll(newSuccessors);
		} while (expanded);
		
		// check if all sub-cone elements are part of the cone
		for (Marking element : subcone) {
			if (!element.isHasCone()) {
				return false;
			}
		}
		
		return true;
	}
	
	/**
	 * check if element is part of the cone
	 * @param element
	 * @return
	 */
	public boolean isInCone(Marking element) {
		for (Marking node : cone) {
			if (element.equals(node)) {
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * print cone with source this node
	 */
	public void printCone() {
		System.out.println("Cone generated by: " + source);
		for (Marking element : cone) {
			System.out.println(element);
		}
		
		System.out.println();
	}
	
	/**
	 * generate TCSSs of cone with source this
	 * use Tarjan's algorithm
	 */
	public void generateTCSSs() {
		stack = new Stack<Marking>();
		
		for (Marking element : cone) {
			if (element.indexUndefined()) {
				strongConnect(element);
			}
		}
	}
	
	private void strongConnect(Marking current) {
		int index = Marking.getNextIndex();
		current.setIndex(index);
		current.setLowlink(index);
		
		// push current node into the stack
		stack.push(current);
		
		HashSet<Marking> successors = current.getForwardSuccessor();
		
		for (Marking successor : successors) {			
			if (successor.indexUndefined()) {
				strongConnect(successor);
				
				int temp = successor.getIndex();
				if (temp < current.getIndex()) {
					current.setIndex(temp);
				}
			} else if (stack.contains(successor)){
				int temp = successor.getIndex();
				if (temp < current.getIndex()) {
					current.setIndex(temp);
				}
			}
		}
		
		// if current is a root node, pop the stack and generate TSCC
		if (current.getLowlink() == current.getIndex()) {
			Marking node; 
			
			// get next scc number
			int scc = Marking.getNextSCC();
			ArrayList<Marking> sccNodes = new ArrayList<Marking>();
			do {
				// mark node as part of current scc
				node = stack.pop();
				node.setScc(scc);
				
				sccNodes.add(node);
			} while(!node.equals(current));
			
			// check if all successors of all scc members are in same scc - found tscc
			boolean isTSCC = true;
			for (Marking sccNode : sccNodes) {
				HashSet<Marking> sccSuccessors = sccNode.getForwardSuccessor();
				
				for (Marking sccSuccessor : sccSuccessors) {
					if (sccSuccessor.getScc() != sccNode.getScc()) {
						isTSCC = false;
					}
				}
			}
			
			// if we found a tscc
			if (isTSCC) {
				System.out.println("Found TSCC....");
				for (Marking sccNode : sccNodes) {
					System.out.println(sccNode);
					sccNode.setInTSCC(true);
				}
			}
		}
	}

	public void setSource(Marking source) {
		this.source = source;
	}

	public Marking getSource() {
		return source;
	}
}
