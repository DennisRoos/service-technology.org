/*****************************************************************************\
 WendyFormula2Bits -- compiling Wendy CNF OGs to Wendy Bit OGs

 Copyright (C) 2009  Christian Sura <christian.sura@uni-rostock.de>

 WendyFormula2Bits is free software: you can redistribute it and/or modify it under the
 terms of the GNU Affero General Public License as published by the Free
 Software Foundation, either version 3 of the License, or (at your option)
 any later version.

 WendyFormula2Bits is distributed in the hope that it will be useful, but WITHOUT ANY
 WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
 more details.

 You should have received a copy of the GNU Affero General Public License
 along with WendyFormula2Bits.  If not, see <http://www.gnu.org/licenses/>. 
\*****************************************************************************/

%error-verbose
%token_table
%defines

%{
#include "config.h"
#include "types-wf2b.h"
#include <iostream>
#include <map>
#include <string>

// from flex
extern char* yytext;
extern int yylex();
extern int yyerror(char const *msg);

// from main
extern std::ostream * myOut;

// data structures
// whether to parse output events
bool outputEvent;
// events and whether they are input events
std::map<std::string, bool> events;


/**
 Nodes' formulae will be evaluated as follows:
 
 Wendy produces formulae in unreduced CNF.
 These formulae will now be processed bottom up, to assign a bit according
 to Lohmann and Wolf [1].

 First, to each literal (i.e. sending/receiving events, "True" and "Final")
 the bit will be assigned that would apply to the whole formula if
 the formula consisted only of this literal (Wendy should neither
 produce "False" nor negations so these will not considered).

 Second, bits assigned to literals of the same clause will be
 OR-connected according to the group table below.

 Third, bits assigned to the clauses will be AND-connected
 according to the other group table below.



 In detail:
 ----------

 Literals:

 The literal "Final" gets the bit "FINAL".
 The literal "True" gets the bit "TRUE".
 A sending event gets the bit "SEND".
 All other literals will get no bit.


 Disjunction group table:

 NONE OR NONE = NONE, for obvious reason. (*)
 NONE OR SEND = NONE, since this clause no longer consits only of sending events
                      the S-bit (assigned to the second literal) does no longer apply [1]. (*)
 NONE OR TRUE = TRUE, since the TRUE bit is only applied to the "True" literal so the whole
                      clause reduces to "True" (this should not be produced by Wendy, anyway).
 NONE OR FINAL = FINAL, this is a clause containing the literal "Final" so the FINAL bit is applied.
                        However, the NONE bit is only applied to receiving literals, the FINAL bit
                        only to the "Final" literal and both are mutual exclusive
                        according to the paper [1] so this case also should not occur.
 SEND OR SEND = SEND, since the clause still consists only of sending events. (*)
 SEND OR TRUE = TRUE, (same reason as for NONE OR TRUE).
 SEND OR FINAL = FINAL, since the clause no longer consists of sending events, the SEND bit
                        does no longer apply, but this is still a clause containing the "Final"
                        literal so the FINAL bit still applies. (*)
 TRUE OR TRUE = TRUE, for obvious reason, but should also not occur in formulae generated by Wendy.
 TRUE OR FINAL = TRUE, (same reason as for NONE OR TRUE).
 FINAL OR FINAL = FINAL, for obvious reason, but should also not occur in formulae generated by Wendy.

 So after all only the disjunctions marked with (*) should be needed for formulae generated by Wendy.


 Conjunction group table:

 NONE AND NONE = NONE, for obvious reason. (*)
 NONE AND SEND = SEND, since the SEND bit marks a clause consisting only of sending events
                       so the SEND bit applies to the while formula. (*)
 NONE AND TRUE = NONE, since the TRUE bit is only applied to a clause reducing to "True"
                       and any formula phi conjugated with "True" reduces to phi again.
                       However, this case should not occur in formulae generated by Wendy.
 NONE AND FINAL = FINAL, since the FINAL bit is only applied to a clause containing the "Final"
                         literal, so this is a formula containing a clause containing
                         the "Final" literal. (*)
 SEND AND SEND = SEND, for obvious reason. (*)
 SEND AND TRUE = SEND, (same reason as for NONE AND TRUE).
 SEND AND FINAL = SEND: There is no formula as "!a AND Final" according to Massuthe [2],
                        so the clause annotated with the FINAL bit contains also other
                        literals than only "Final". According to Lohmann and Wolf there
                        is no clause containing both "Final" and receiving events [1],
                        so the clause annotated with the FINAL bit consists of "Final"
                        and sending events.
                        According to Massuthe there is no such formula as "!a AND !b",
                        so under all clauses only containing of sending events there is
                        one minimal clause being subset of all other sending clauses.
                        This minimal clause therefore is also a subset of the clause
                        annotated with the FINAL bit.
                        So if there are both a SEND clause and a FINAL clause, there is also
                        a minimal SEND clause reducing the FINAL clause away by absorption law. (*)
 TRUE AND TRUE = TRUE, for obvious reason but should not occur in formulae generated by Wendy.
 TRUE AND FINAL = FINAL, (same reason as for NONE AND TRUE).
 FINAL AND FINAL = FINAL, for obvious reason but should not occur in formulae generated by Wendy.

 So after all only the conjunctions marked with (*) should be needed for formulae generated by Wendy.


 References:
 [1] Niels Lohmann and Karsten Wolf. Compact Representations and Efficient Algorithms for Operating Guidelines. Fundam. Inform., 108(1-2):43-62, 2011.
 [2] Peter Massuthe. OG Example Collection, 2008.

 **/

Bit_T bitsOr[][4] = {{NONE, NONE, TRUE, FINAL},
                    {NONE, SEND, TRUE, FINAL},
                    {TRUE, TRUE, TRUE, TRUE},
                    {FINAL, FINAL, TRUE, FINAL}};

Bit_T bitsAnd[][4] = {{NONE, SEND, NONE, FINAL},
                     {SEND, SEND, SEND, SEND},
                     {NONE, SEND, TRUE, FINAL},
                     {FINAL, SEND, FINAL, FINAL}};



char bitLabels[][10] = {"\n", " :: S\n", " :: T\n", " :: F\n"};

%}


%token KEY_NODES
%token KEY_INTERFACE KEY_INPUT KEY_OUTPUT KEY_SYNCHRONOUS
%token COMMA COLON DOUBLECOLON SEMICOLON IDENT ARROW NUMBER
%token KEY_TRUE KEY_FALSE KEY_FINAL BIT_F BIT_S BIT_T
%token LPAR RPAR

%union {
    char *str;
    unsigned int value;
    Bit_T bit;
}

%type <value> NUMBER
%type <str>   IDENT
%type <bit>   formula annotation

%left OP_OR
%left OP_AND
%left OP_NOT

%start og


%%


og:
  KEY_INTERFACE
  { (*myOut) << "INTERFACE\n"; }
  input output synchronous
  { (*myOut) << "\nNODES\n"; }
  KEY_NODES nodes
  { (*myOut) << std::endl << std::flush; }
;


input:
  /* empty */
| KEY_INPUT
  {
    (*myOut) << "  INPUT\n    ";
    outputEvent = false;
  }
  identlist SEMICOLON
  { (*myOut) << ";\n"; }
;


output:
  /* empty */
| KEY_OUTPUT
  {
    (*myOut) << "  OUTPUT\n    ";
    outputEvent = true;
  }
  identlist SEMICOLON
  { (*myOut) << ";\n"; }
;


synchronous:
  /* empty */
| KEY_SYNCHRONOUS
  {
    (*myOut) << "  SYNCHRONOUS\n    ";
    outputEvent = false;
  }
  identlist SEMICOLON
  { (*myOut) << ";\n"; }
;


identlist:
  /* empty */
| IDENT
  {
    events[$1] = outputEvent;
    (*myOut) << $1;
    free($1);
  }
| identlist COMMA IDENT
  {
    events[$3] = outputEvent;
    (*myOut) << ", " << $3;
    free($3);
  }
;


nodes:
  node
| nodes node
;


node:
  NUMBER annotation 
  {
    (*myOut) << "  " << $1 << bitLabels[$2];
    // if we read a formula and this bit was not overwritten, we only read send events
  }
  successors
;


annotation:
  /* empty; i.e. we do not write a bit */ 
  { $$ = NONE; }
| COLON formula     { $$ = $2; }
| DOUBLECOLON BIT_S { yyerror("this seems to be already a bit-OG"); }
| DOUBLECOLON BIT_F { yyerror("this seems to be already a bit-OG"); }
| DOUBLECOLON BIT_T { yyerror("this seems to be already a bit-OG"); }
;


formula:
  LPAR formula RPAR       { $$ = $2; }
| formula OP_AND formula  { $$ = bitsAnd[$1][$3]; }
| formula OP_OR formula   { $$ = bitsOr[$1][$3]; }
| OP_NOT formula          { $$ = NONE; }
| KEY_FINAL               { $$ = FINAL; } 
| KEY_TRUE                { $$ = TRUE; }
| KEY_FALSE               { $$ = NONE; }
| IDENT
  { 
    $$ = (events[$1] ? SEND : NONE);
    free($1);
  }
;


successors:
  /* empty */
| successors IDENT ARROW NUMBER
  {
    (*myOut) << "    " << $2 << " -> " << $4 << "\n";
    free($2);
  }
;


%%


