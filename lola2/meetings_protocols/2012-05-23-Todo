* Niels: Rewriting: Bei Elimination von Negationen direkt auf <= erzeugen.

* Andreas: Algorithmus f端r positive/negative Faktoren aus <algorithms> raussuchen

* Karsten: Klassen f端r TRUE/FALSE; Abfrage vor Tiefensuche, ob Wert konstant

* Niels: im Unparser Typen anpassen (index_t, size_t, ...)

* Syntax: FIREABLE(t) AND p >= 0

Statepredicate -> FORMULA ...
Deadlock
Liveness
LTL-Ausschnitt FG GF F
CTL
Reversibility
Boundedness
Boundedplace
Deadtransition -> Atomic Proposition "FIREABLE" in FORMULA
Homestates


Neu:

REACHABLE (EF) / INVARIANT (AG) / IMPOSSIBLE (AG NOT) -> Statepredicate

FORMULA



EF (FIREABLE(t))
EXPATH EVENTUALLY FIREABLE(t)
REACHABLE FIREABLE(t)

AG NOT DEADLOCK
ALLPATH ALWAYS (NOT DEADLOCK XOR 1=3*p4)


* Niels: Commandline-Parameter f端r Findpath
* Findpath: Keinen Store anlegen; Statusmeldungen


* Andreas:

// copy initial marking into current marking
memcpy(Marking::Current, Marking::Initial, Net::Card[PL] * SIZEOF_INDEX_T);
Marking::HashCurrent = Marking::HashInitial;

in Funktion auslagern.



* Karsten: Deadlocks und Findpath

* Karsten: Findpath und Zeugenpfad

* Karsten: Transitionsauswahl auslagern wie bei Store

* Niels: Dreiwertige Logik f端r Ausgaben (Bloom, Findpath, Memory-Overflow, ...)

