/* -*- mode: c++ -*- */

/*!
 * \file    petrinet-input-owfn-parser.h
 *
 * \brief   bison parser for OWFN files
 *
 * \author  Robert Waltemath <robert.waltemath@uni-rostock.de>
 *          last changes of: $Author$
 *
 * \since   2008/11/10
 *
 * \date    $Date$
 *
 * \note    This file is part of ...
 *
 *          Large parts of the code are copied from the bpel2owfn OWFN parser.
 *          If I had the time to refactor this: Create an AST containing C++
 *          objects first and then construct the PetriNet instance by some 
 *          visitor strategy ...
 *
 * \version $Revision$
 */


 /*****************************************************************************
  * bison options 
  ****************************************************************************/

/* plain c parser: the prefix is our "namespace" */
%name-prefix="pnapi_owfn_"

/* write tokens to petrinet-input-owfn-parser.h for use by scanner */
%defines


 /*****************************************************************************
  * C declarations
  ****************************************************************************/
%{

#include <string>

#include "petrinet.h"
#include "helpers.h"

using namespace PNapi;

// defined in petrinet-input-owfn-lexer.cc (generated by flex)
extern int yylex();

// global variable for resulting net
PetriNet PN;

// global variables for use in actions during net construction
int readmode = 0;
string nodename;
string current_port;
Transition * t = NULL; 
set<string> in;
set<string> out;
set<pair<Place *, unsigned int> > finalMarking;

// standard error function (defined in epilogue)
int yyerror(const char *);

%}


 /*****************************************************************************
  * types, tokens, start symbol
  ****************************************************************************/

%union {
  char * yt_string;
}

%type <yt_string> IDENT
%type <yt_string> nodeident
%type <yt_string> NUMBER
%type <yt_string> NEGATIVE_NUMBER

%token KEY_SAFE KEY_PLACE KEY_INTERNAL KEY_INPUT KEY_OUTPUT KEY_PORTS
%token KEY_MARKING KEY_FINALMARKING KEY_FINALCONDITION
%token KEY_TRANSITION KEY_CONSUME KEY_PRODUCE
%token KEY_ALL_OTHER_PLACES_EMPTY
%token KEY_ALL_OTHER_INTERNAL_PLACES_EMPTY
%token KEY_ALL_OTHER_EXTERNAL_PLACES_EMPTY
%token KEY_MAX_UNIQUE_EVENTS KEY_ON_LOOP KEY_MAX_OCCURRENCES
%token KEY_TRUE KEY_FALSE LCONTROL RCONTROL
%token COMMA COLON SEMICOLON IDENT NUMBER NEGATIVE_NUMBER
%token LPAR RPAR

%left OP_OR
%left OP_AND
%left OP_NOT
%nonassoc OP_EQ OP_NE OP_GT OP_LT OP_GE OP_LE

%start net


 /*****************************************************************************
  * grammar rules 
  ****************************************************************************/
%%

net:                 KEY_PLACE place_area port_area KEY_MARKING markinglist 
                     SEMICOLON final transitionlist
                   ;

final:               KEY_FINALMARKING finalmarkinglist SEMICOLON
                   | KEY_FINALCONDITION statepredicate SEMICOLON
                   ;

place_area:          place_area_internal place_area_input place_area_output
	           | place_area_lola
                   ;

place_area_input:    { readmode = 0; } KEY_INPUT placelists SEMICOLON
                   | /* empty */
                   ;

place_area_output:   { readmode = 1; } KEY_OUTPUT placelists SEMICOLON
                   | /* empty */
                   ;

place_area_internal: { readmode = 2; } KEY_INTERNAL placelists SEMICOLON
                   | /* empty */
                   ;

place_area_lola:     { readmode = 2; } placelists SEMICOLON
                   ;

placelists:          capacity placelist 
                   | placelists SEMICOLON capacity placelist
                   ;

capacity:            /* empty */
                   | KEY_SAFE COLON  
                   | KEY_SAFE NUMBER COLON 
                   ;

placelist:           placelist COMMA place 
                   | place
                   | /* empty */ 
                   ;

place:               nodeident controlcommands {
                                   switch (readmode) {
                                     case 0: PN.newPlace(nodename, IN); break;
                                     case 1: PN.newPlace(nodename, OUT); break;
				     case 2: PN.newPlace(nodename); break;
				     case 3: break;
				   } }
                   ;     

nodeident:           IDENT  { nodename = strip_namespace($1); }
                   | NUMBER { nodename = strip_namespace($1); }
                   ;

controlcommands:     /* emtpy */
                   | LCONTROL commands RCONTROL
                   ;

commands:            { yyerror("control commands not supported"); /* FIXME */ }
                   ;

markinglist:      /* empty */ 
                | marking
                | markinglist COMMA marking
                ;

marking:          nodeident COLON NUMBER { (PN.findPlace(nodename))->mark(
                                               toUInt(strip_namespace($3))); } 
                | nodeident              { (PN.findPlace(nodename))->mark(); }
                ;

finalmarkinglist: /* empty */
                | finalmarking { if (!finalMarking.empty()) {
				   PN.final_set_list.push_back(finalMarking);
				   finalMarking.clear();
				 } }
                | finalmarkinglist COMMA finalmarking { 
                                 if (!finalMarking.empty()) {
				   PN.final_set_list.push_back(finalMarking);
				   finalMarking.clear();
				 } }
                ;

finalmarking:     nodeident COLON NUMBER {
                      (PN.findPlace(nodename))->isFinal = true;
		      finalMarking.insert(pair<Place *, unsigned int>
					  (PN.findPlace(nodename),
					   toUInt(strip_namespace($3)))); }
                | nodeident {
		      (PN.findPlace(nodename))->isFinal = true;
		      finalMarking.insert(pair<Place *, unsigned int>
					  (PN.findPlace(nodename), 1)); }
                ;

port_area:        /* empty */
                | KEY_PORTS port_list
                ;

port_list:        port_definition
                | port_list port_definition
                ;

port_definition:  nodeident { current_port = std::string($1); } 
                  COLON port_participant_list SEMICOLON
                ;

port_participant_list: nodeident { 
                     PN.setPlacePort(PN.findPlace(string($1)), current_port); }
                | port_participant_list COMMA nodeident { 
                     PN.setPlacePort(PN.findPlace(string($3)), current_port); }
                ;

transitionlist:   transitionlist transition
                | /* empty */
                ;

transition:       KEY_TRANSITION tname      { t = PN.newTransition(nodename); }
                  annotation KEY_CONSUME        { readmode = 4; } 
                  arclist SEMICOLON KEY_PRODUCE { readmode = 5; } 
                  arclist SEMICOLON
                ;

tname:            IDENT  { nodename = strip_namespace($1); }
                | NUMBER { nodename = strip_namespace($1); }
                ;

annotation:       /* empty */
                | LCONTROL annotation_list RCONTROL
                ;

annotation_list:  IDENT { t->add_label($1); }
                | IDENT { t->add_label($1); } COMMA annotation_list
                ;

arclist:          /* empty */
                | arc 
                | arc COMMA arclist 
                ;

arc:              nodeident COLON NUMBER {
                         if (readmode == 4) 
			   PN.newArc(PN.findPlace(nodename), t, STANDARD, 
				     toInt(strip_namespace($3))); 
			 if (readmode == 5) 
			   PN.newArc(t, PN.findPlace(nodename), STANDARD, 
				     toInt(strip_namespace($3))); }
                | nodeident {
		         if (readmode == 4) 
			   PN.newArc(PN.findPlace(nodename), t, STANDARD, 1); 
			 if (readmode == 5) 
			   PN.newArc(t, PN.findPlace(nodename), STANDARD, 1); }
                ;

statepredicate: /* empty */ /* FIXME
              | LPAR                  { globals::owfn_statepredicate += "("; } 
                statepredicate RPAR   { globals::owfn_statepredicate += ")"; } 
              | statepredicate OP_AND { globals::owfn_statepredicate = 
		                      globals::owfn_statepredicate + " AND "; }
                statepredicate
              | statepredicate OP_AND KEY_ALL_OTHER_PLACES_EMPTY 
                                      { globals::owfn_statepredicate = 
					  globals::owfn_statepredicate + 
					  " AND ALL_OTHER_PLACES_EMPTY"; }
              | statepredicate OP_AND KEY_ALL_OTHER_INTERNAL_PLACES_EMPTY 
                                      { globals::owfn_statepredicate = 
					  globals::owfn_statepredicate + 
				      " AND ALL_OTHER_INTERNAL_PLACES_EMPTY"; }
              | statepredicate OP_AND KEY_ALL_OTHER_EXTERNAL_PLACES_EMPTY 
                                      { globals::owfn_statepredicate = 
					  globals::owfn_statepredicate + 
				      " AND ALL_OTHER_EXTERNAL_PLACES_EMPTY"; }
              | statepredicate OP_OR  { globals::owfn_statepredicate = 
		                       globals::owfn_statepredicate + " OR "; }
                statepredicate 
              | OP_NOT                { globals::owfn_statepredicate = 
		                       globals::owfn_statepredicate + "NOT "; }
                statepredicate 
              | nodeident OP_EQ NUMBER 
  {
    globals::owfn_statepredicate = globals::owfn_statepredicate + " " + nodename + " = " + strip_namespace($3->name); 
    Place * p = PN.findPlace(nodename);
    assert(p != NULL);
    p->isFinal = true;
  }
| nodeident OP_NE NUMBER 
  {
    globals::owfn_statepredicate = globals::owfn_statepredicate + " " + nodename + " != " + strip_namespace($3->name);  
    Place * p = PN.findPlace(nodename);
    assert(p != NULL);
    p->isFinal = true;
  }
| nodeident OP_LT NUMBER 
  {
    globals::owfn_statepredicate = globals::owfn_statepredicate + " " + nodename + " < " + strip_namespace($3->name);  
    Place * p = PN.findPlace(nodename);
    assert(p != NULL);
    p->isFinal = true;
  }
| nodeident OP_GT NUMBER 
  {
    globals::owfn_statepredicate = globals::owfn_statepredicate + " " + nodename + " > " + strip_namespace($3->name);  
    Place * p = PN.findPlace(nodename);
    assert(p != NULL);
    p->isFinal = true;
  }
| nodeident OP_GE NUMBER 
  {
    globals::owfn_statepredicate = globals::owfn_statepredicate + " " + nodename + " >= " + strip_namespace($3->name);  
    Place * p = PN.findPlace(nodename);
    assert(p != NULL);
    p->isFinal = true;
  }
| nodeident OP_LE NUMBER 
  {
    globals::owfn_statepredicate = globals::owfn_statepredicate + " " + nodename + " <= " + strip_namespace($3->name);  
    Place * p = PN.findPlace(nodename);
    assert(p != NULL);
    p->isFinal = true;
  }
  ; */


 /*****************************************************************************
  * C definitions
  ****************************************************************************/
%%

int yyerror(const char * msg)
{
  throw msg;
}
